// automatically generated by rust-bindgen

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201505;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 25;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __glibc_c99_flexarr_available: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __GLIBC_USE_LIB_EXT2: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: ::std::os::raw::c_uint = 0;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const true_: ::std::os::raw::c_uint = 1;
pub const false_: ::std::os::raw::c_uint = 0;
pub const __bool_true_false_are_defined: ::std::os::raw::c_uint = 1;
pub const CLINGO_VERSION_MAJOR: ::std::os::raw::c_uint = 5;
pub const CLINGO_VERSION_MINOR: ::std::os::raw::c_uint = 2;
pub const CLINGO_VERSION_REVISION: ::std::os::raw::c_uint = 0;
pub const CLINGO_VERSION: &'static [u8; 6usize] = b"5.2.0\x00";
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(::std::mem::size_of::<max_align_t>(),
               32usize,
               concat!("Size of: ", stringify!(max_align_t)));
    assert_eq!(unsafe {
                   &(*(0 as *const max_align_t)).__clang_max_align_nonce1 as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(max_align_t),
                       "::",
                       stringify!(__clang_max_align_nonce1)));
    assert_eq!(unsafe {
                   &(*(0 as *const max_align_t)).__clang_max_align_nonce2 as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(max_align_t),
                       "::",
                       stringify!(__clang_max_align_nonce2)));
}
impl Clone for max_align_t {
    fn clone(&self) -> Self {
        *self
    }
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>(),
               8usize,
               concat!("Size of: ", stringify!(__fsid_t)));
    assert_eq!(::std::mem::align_of::<__fsid_t>(),
               4usize,
               concat!("Alignment of ", stringify!(__fsid_t)));
    assert_eq!(unsafe { &(*(0 as *const __fsid_t)).__val as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(__fsid_t),
                       "::",
                       stringify!(__val)));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self {
        *self
    }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
/// Signed integer type used for aspif and solver literals.
pub type clingo_literal_t = i32;
/// Unsigned integer type used for aspif atoms.
pub type clingo_atom_t = u32;
/// Unsigned integer type used in various places.
pub type clingo_id_t = u32;
/// Signed integer type for weights in sum aggregates and minimize constraints.
pub type clingo_weight_t = i32;
#[repr(u32)]
/// Enumeration of error codes.
///
///
/// **Note:** Errors can only be recovered from if explicitly mentioned; most
/// functions do not provide strong exception guarantees.  This means that in
/// case of errors associated objects cannot be used further.  If such an
/// object has a free function, this function can and should still be called.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_error {
    clingo_error_success = 0,
    clingo_error_runtime = 1,
    clingo_error_logic = 2,
    clingo_error_bad_alloc = 3,
    clingo_error_unknown = 4,
}
/// Corresponding type to ::clingo_error.
pub type clingo_error_t = ::std::os::raw::c_int;
extern "C" {
    /// Convert error code into string.
    pub fn clingo_error_string(code: clingo_error_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get the last error code set by a clingo API call.
    ///
    /// **Note:** Each thread has its own local error code.
    ///
    /// **Returns** error code
    pub fn clingo_error_code() -> clingo_error_t;
}
extern "C" {
    /// Get the last error message set if an API call fails.
    ///
    /// **Note:** Each thread has its own local error message.
    ///
    /// **Returns** error message or NULL
    pub fn clingo_error_message() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Set a custom error code and message in the active thread.
    ///
    /// **Parameters:**
    ///
    /// * `code` the error code
    /// * `message` the error message
    pub fn clingo_set_error(code: clingo_error_t, message: *const ::std::os::raw::c_char);
}
#[repr(u32)]
/// Enumeration of warning codes.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_warning {
    clingo_warning_operation_undefined = 0,
    clingo_warning_runtime_error = 1,
    clingo_warning_atom_undefined = 2,
    clingo_warning_file_included = 3,
    clingo_warning_variable_unbounded = 4,
    clingo_warning_global_variable = 5,
    clingo_warning_other = 6,
}
/// Corresponding type to ::clingo_warning.
pub type clingo_warning_t = ::std::os::raw::c_int;
extern "C" {
    /// Convert warning code into string.
    pub fn clingo_warning_string(code: clingo_warning_t) -> *const ::std::os::raw::c_char;
}
/// Callback to intercept warning messages.
///
/// **Parameters:**
///
/// * `code` associated warning code
/// * `message` warning message
/// * `data` user data for callback
///
/// @see clingo_control_new()
/// @see clingo_parse_term()
/// @see clingo_parse_program()
pub type clingo_logger_t =
    ::std::option::Option<unsafe extern "C" fn(code: clingo_warning_t,
                                                 message: *const ::std::os::raw::c_char,
                                                 data: *mut ::std::os::raw::c_void)>;
extern "C" {
    /// Obtain the clingo version.
    ///
    /// **Parameters:**
    ///
    /// * `major` major version number
    /// * `minor` minor version number
    /// * `revision` revision number
    pub fn clingo_version(major: *mut ::std::os::raw::c_int,
                          minor: *mut ::std::os::raw::c_int,
                          revision: *mut ::std::os::raw::c_int);
}
#[repr(u32)]
/// Represents three-valued truth values.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_truth_value {
    clingo_truth_value_free = 0,
    clingo_truth_value_true = 1,
    clingo_truth_value_false = 2,
}
/// Corresponding type to ::clingo_truth_value.
pub type clingo_truth_value_t = ::std::os::raw::c_int;
/// Represents a source code location marking its beginnig and end.
///
///
/// **Note:** Not all locations refer to physical files.
/// By convention, such locations use a name put in angular brackets as filename.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_location {
    /// < the file where the location begins
    pub begin_file: *const ::std::os::raw::c_char,
    /// < the file where the location ends
    pub end_file: *const ::std::os::raw::c_char,
    /// < the line where the location begins
    pub begin_line: usize,
    /// < the line where the location ends
    pub end_line: usize,
    /// < the column where the location begins
    pub begin_column: usize,
    /// < the column where the location ends
    pub end_column: usize,
}
#[test]
fn bindgen_test_layout_clingo_location() {
    assert_eq!(::std::mem::size_of::<clingo_location>(),
               48usize,
               concat!("Size of: ", stringify!(clingo_location)));
    assert_eq!(::std::mem::align_of::<clingo_location>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_location)));
    assert_eq!(unsafe { &(*(0 as *const clingo_location)).begin_file as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_location),
                       "::",
                       stringify!(begin_file)));
    assert_eq!(unsafe { &(*(0 as *const clingo_location)).end_file as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_location),
                       "::",
                       stringify!(end_file)));
    assert_eq!(unsafe { &(*(0 as *const clingo_location)).begin_line as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_location),
                       "::",
                       stringify!(begin_line)));
    assert_eq!(unsafe { &(*(0 as *const clingo_location)).end_line as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_location),
                       "::",
                       stringify!(end_line)));
    assert_eq!(unsafe { &(*(0 as *const clingo_location)).begin_column as *const _ as usize },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_location),
                       "::",
                       stringify!(begin_column)));
    assert_eq!(unsafe { &(*(0 as *const clingo_location)).end_column as *const _ as usize },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_location),
                       "::",
                       stringify!(end_column)));
}
impl Clone for clingo_location {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_location_t = clingo_location;
/// Represents a predicate signature.
///
/// Signatures have a name and an arity, and can be positive or negative (to
/// represent classical negation).
pub type clingo_signature_t = u64;
extern "C" {
    /// Create a new signature.
    ///
    /// **Parameters:**
    ///
    /// * `name` name of the signature
    /// * `arity` arity of the signature
    /// * `positive` false if the signature has a classical negation sign
    /// * `signature` the resulting signature
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_signature_create(name: *const ::std::os::raw::c_char,
                                   arity: u32,
                                   positive: bool,
                                   signature: *mut clingo_signature_t)
                                   -> bool;
}
extern "C" {
    /// Get the name of a signature.
    ///
    /// **Parameters:**
    ///
    /// * `signature` the target signature
    ///
    /// **Returns** the name of the signature
    pub fn clingo_signature_name(signature: clingo_signature_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get the arity of a signature.
    ///
    /// **Parameters:**
    ///
    /// * `signature` the target signature
    ///
    /// **Returns** the arity of the signature
    pub fn clingo_signature_arity(signature: clingo_signature_t) -> u32;
}
extern "C" {
    /// Whether the signature is positive (is not classically negated).
    ///
    /// **Parameters:**
    ///
    /// * `signature` the target signature
    ///
    /// **Returns** whether the signature has no sign
    pub fn clingo_signature_is_positive(signature: clingo_signature_t) -> bool;
}
extern "C" {
    /// Whether the signature is negative (is classically negated).
    ///
    /// **Parameters:**
    ///
    /// * `signature` the target signature
    ///
    /// **Returns** whether the signature has a sign
    pub fn clingo_signature_is_negative(signature: clingo_signature_t) -> bool;
}
extern "C" {
    /// Check if two signatures are equal.
    ///
    /// **Parameters:**
    ///
    /// * `a` first signature
    /// * `b` second signature
    ///
    /// **Returns** whether a == b
    pub fn clingo_signature_is_equal_to(a: clingo_signature_t, b: clingo_signature_t) -> bool;
}
extern "C" {
    /// Check if a signature is less than another signature.
    ///
    /// Signatures are compared first by sign (unsigned < signed), then by arity,
    /// then by name.
    ///
    /// **Parameters:**
    ///
    /// * `a` first signature
    /// * `b` second signature
    ///
    /// **Returns** whether a < b
    pub fn clingo_signature_is_less_than(a: clingo_signature_t, b: clingo_signature_t) -> bool;
}
extern "C" {
    /// Calculate a hash code of a signature.
    ///
    /// **Parameters:**
    ///
    /// * `signature` the target signature
    ///
    /// **Returns** the hash code of the signature
    pub fn clingo_signature_hash(signature: clingo_signature_t) -> usize;
}
#[repr(u32)]
/// Enumeration of available symbol types.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_symbol_type {
    clingo_symbol_type_infimum = 0,
    clingo_symbol_type_number = 1,
    clingo_symbol_type_string = 4,
    clingo_symbol_type_function = 5,
    clingo_symbol_type_supremum = 7,
}
/// Corresponding type to ::clingo_symbol_type.
pub type clingo_symbol_type_t = ::std::os::raw::c_int;
/// Represents a symbol.
///
/// This includes numbers, strings, functions (including constants when
/// arguments are empty and tuples when the name is empty), <tt>\#inf</tt> and <tt>\#sup</tt>.
pub type clingo_symbol_t = u64;
/// Represents a symbolic literal.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_symbolic_literal {
    /// < the associated symbol (must be a function)
    pub symbol: clingo_symbol_t,
    /// < whether the literal has a sign
    pub positive: bool,
}
#[test]
fn bindgen_test_layout_clingo_symbolic_literal() {
    assert_eq!(::std::mem::size_of::<clingo_symbolic_literal>(),
               16usize,
               concat!("Size of: ", stringify!(clingo_symbolic_literal)));
    assert_eq!(::std::mem::align_of::<clingo_symbolic_literal>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_symbolic_literal)));
    assert_eq!(unsafe { &(*(0 as *const clingo_symbolic_literal)).symbol as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_symbolic_literal),
                       "::",
                       stringify!(symbol)));
    assert_eq!(unsafe { &(*(0 as *const clingo_symbolic_literal)).positive as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_symbolic_literal),
                       "::",
                       stringify!(positive)));
}
impl Clone for clingo_symbolic_literal {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_symbolic_literal_t = clingo_symbolic_literal;
extern "C" {
    /// Construct a symbol representing a number.
    ///
    /// **Parameters:**
    ///
    /// * `number` the number
    /// * `symbol` the resulting symbol
    pub fn clingo_symbol_create_number(number: ::std::os::raw::c_int,
                                       symbol: *mut clingo_symbol_t);
}
extern "C" {
    /// Construct a symbol representing \#sup.
    ///
    /// * `symbol` the resulting symbol
    pub fn clingo_symbol_create_supremum(symbol: *mut clingo_symbol_t);
}
extern "C" {
    /// Construct a symbol representing <tt>\#inf</tt>.
    ///
    /// * `symbol` the resulting symbol
    pub fn clingo_symbol_create_infimum(symbol: *mut clingo_symbol_t);
}
extern "C" {
    /// Construct a symbol representing a string.
    ///
    /// **Parameters:**
    ///
    /// * `string` the string
    /// * `symbol` the resulting symbol
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_symbol_create_string(string: *const ::std::os::raw::c_char,
                                       symbol: *mut clingo_symbol_t)
                                       -> bool;
}
extern "C" {
    /// Construct a symbol representing an id.
    ///
    ///
    /// **Note:** This is just a shortcut for clingo_symbol_create_function() with
    /// empty arguments.
    ///
    /// **Parameters:**
    ///
    /// * `name` the name
    /// * `positive` whether the symbol has a classical negation sign
    /// * `symbol` the resulting symbol
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_symbol_create_id(name: *const ::std::os::raw::c_char,
                                   positive: bool,
                                   symbol: *mut clingo_symbol_t)
                                   -> bool;
}
extern "C" {
    /// Construct a symbol representing a function or tuple.
    ///
    ///
    /// **Note:** To create tuples, the empty string has to be used as name.
    ///
    /// **Parameters:**
    ///
    /// * `name` the name of the function
    /// * `arguments` the arguments of the function
    /// * `arguments_size` the number of arguments
    /// * `positive` whether the symbol has a classical negation sign
    /// * `symbol` the resulting symbol
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_symbol_create_function(name: *const ::std::os::raw::c_char,
                                         arguments: *const clingo_symbol_t,
                                         arguments_size: usize,
                                         positive: bool,
                                         symbol: *mut clingo_symbol_t)
                                         -> bool;
}
extern "C" {
    /// Get the number of a symbol.
    ///
    /// **Parameters:**
    ///
    /// * `symbol` the target symbol
    /// * `number` the resulting number
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_number
    pub fn clingo_symbol_number(symbol: clingo_symbol_t,
                                number: *mut ::std::os::raw::c_int)
                                -> bool;
}
extern "C" {
    /// Get the name of a symbol.
    ///
    /// **Parameters:**
    ///
    /// * `symbol` the target symbol
    /// * `name` the resulting name
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_function
    pub fn clingo_symbol_name(symbol: clingo_symbol_t,
                              name: *mut *const ::std::os::raw::c_char)
                              -> bool;
}
extern "C" {
    /// Get the string of a symbol.
    ///
    /// **Parameters:**
    ///
    /// * `symbol` the target symbol
    /// * `string` the resulting string
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_string
    pub fn clingo_symbol_string(symbol: clingo_symbol_t,
                                string: *mut *const ::std::os::raw::c_char)
                                -> bool;
}
extern "C" {
    /// Check if a function is positive (does not have a sign).
    ///
    /// **Parameters:**
    ///
    /// * `symbol` the target symbol
    /// * `positive` the result
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_function
    pub fn clingo_symbol_is_positive(symbol: clingo_symbol_t, positive: *mut bool) -> bool;
}
extern "C" {
    /// Check if a function is negative (has a sign).
    ///
    /// **Parameters:**
    ///
    /// * `symbol` the target symbol
    /// * `negative` the result
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_function
    pub fn clingo_symbol_is_negative(symbol: clingo_symbol_t, negative: *mut bool) -> bool;
}
extern "C" {
    /// Get the arguments of a symbol.
    ///
    /// **Parameters:**
    ///
    /// * `symbol` the target symbol
    /// * `arguments` the resulting arguments
    /// * `arguments_size` the number of arguments
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_runtime if symbol is not of type ::clingo_symbol_type_function
    pub fn clingo_symbol_arguments(symbol: clingo_symbol_t,
                                   arguments: *mut *const clingo_symbol_t,
                                   arguments_size: *mut usize)
                                   -> bool;
}
extern "C" {
    /// Get the type of a symbol.
    ///
    /// **Parameters:**
    ///
    /// * `symbol` the target symbol
    ///
    /// **Returns** the type of the symbol
    pub fn clingo_symbol_type(symbol: clingo_symbol_t) -> clingo_symbol_type_t;
}
extern "C" {
    /// Get the size of the string representation of a symbol (including the terminating 0).
    ///
    /// **Parameters:**
    ///
    /// * `symbol` the target symbol
    /// * `size` the resulting size
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_symbol_to_string_size(symbol: clingo_symbol_t, size: *mut usize) -> bool;
}
extern "C" {
    /// Get the string representation of a symbol.
    ///
    /// **Parameters:**
    ///
    /// * `symbol` the target symbol
    /// * `string` the resulting string
    /// * `size` the size of the string
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    ///
    /// @see clingo_symbol_to_string_size()
    pub fn clingo_symbol_to_string(symbol: clingo_symbol_t,
                                   string: *mut ::std::os::raw::c_char,
                                   size: usize)
                                   -> bool;
}
extern "C" {
    /// Check if two symbols are equal.
    ///
    /// **Parameters:**
    ///
    /// * `a` first symbol
    /// * `b` second symbol
    ///
    /// **Returns** whether a == b
    pub fn clingo_symbol_is_equal_to(a: clingo_symbol_t, b: clingo_symbol_t) -> bool;
}
extern "C" {
    /// Check if a symbol is less than another symbol.
    ///
    /// Symbols are first compared by type.  If the types are equal, the values are
    /// compared (where strings are compared using strcmp).  Functions are first
    /// compared by signature and then lexicographically by arguments.
    ///
    /// **Parameters:**
    ///
    /// * `a` first symbol
    /// * `b` second symbol
    ///
    /// **Returns** whether a < b
    pub fn clingo_symbol_is_less_than(a: clingo_symbol_t, b: clingo_symbol_t) -> bool;
}
extern "C" {
    /// Calculate a hash code of a symbol.
    ///
    /// **Parameters:**
    ///
    /// * `symbol` the target symbol
    ///
    /// **Returns** the hash code of the symbol
    pub fn clingo_symbol_hash(symbol: clingo_symbol_t) -> usize;
}
extern "C" {
    /// Internalize a string.
    ///
    /// This functions takes a string as input and returns an equal unique string
    /// that is (at the moment) not freed until the program is closed.  All strings
    /// returned from clingo API functions are internalized and must not be freed.
    ///
    /// **Parameters:**
    ///
    /// * `string` the string to internalize
    /// * `result` the internalized string
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_add_string(string: *const ::std::os::raw::c_char,
                             result: *mut *const ::std::os::raw::c_char)
                             -> bool;
}
extern "C" {
    /// Parse a term in string form.
    ///
    /// The result of this function is a symbol. The input term can contain
    /// unevaluated functions, which are evaluated during parsing.
    ///
    /// **Parameters:**
    ///
    /// * `string` the string to parse
    /// * `logger` optional logger to report warnings during parsing
    /// * `logger_data` user data for the logger
    /// * `message_limit` maximum number of times to call the logger
    /// * `symbol` the resulting symbol
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    /// - ::clingo_error_runtime if parsing fails
    pub fn clingo_parse_term(string: *const ::std::os::raw::c_char,
                             logger: clingo_logger_t,
                             logger_data: *mut ::std::os::raw::c_void,
                             message_limit: ::std::os::raw::c_uint,
                             symbol: *mut clingo_symbol_t)
                             -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_symbolic_atoms([u8; 0]);
/// Object to inspect symbolic atoms in a program---the relevant Herbrand base
/// gringo uses to instantiate programs.
///
/// @see clingo_control_symbolic_atoms()
pub type clingo_symbolic_atoms_t = clingo_symbolic_atoms;
/// Object to iterate over symbolic atoms.
///
/// Such an iterator either points to a symbolic atom within a sequence of
/// symbolic atoms or to the end of the sequence.
///
///
/// **Note:** Iterators are valid as long as the underlying sequence is not modified.
/// Operations that can change this sequence are ::clingo_control_ground(),
/// ::clingo_control_cleanup(), and functions that modify the underlying
/// non-ground program.
pub type clingo_symbolic_atom_iterator_t = u64;
extern "C" {
    /// Get the number of different atoms occurring in a logic program.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` the target
    /// * `size` the number of atoms
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_symbolic_atoms_size(atoms: *mut clingo_symbolic_atoms_t,
                                      size: *mut usize)
                                      -> bool;
}
extern "C" {
    /// Get a forward iterator to the beginning of the sequence of all symbolic
    /// atoms optionally restricted to a given signature.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` the target
    /// * `signature` optional signature
    /// * `iterator` the resulting iterator
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_symbolic_atoms_begin(atoms: *mut clingo_symbolic_atoms_t,
                                       signature: *const clingo_signature_t,
                                       iterator: *mut clingo_symbolic_atom_iterator_t)
                                       -> bool;
}
extern "C" {
    /// Iterator pointing to the end of the sequence of symbolic atoms.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` the target
    /// * `iterator` the resulting iterator
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_symbolic_atoms_end(atoms: *mut clingo_symbolic_atoms_t,
                                     iterator: *mut clingo_symbolic_atom_iterator_t)
                                     -> bool;
}
extern "C" {
    /// Find a symbolic atom given its symbolic representation.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` the target
    /// * `symbol` the symbol to lookup
    /// * `iterator` iterator pointing to the symbolic atom or to the end
    /// of the sequence if no corresponding atom is found
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_symbolic_atoms_find(atoms: *mut clingo_symbolic_atoms_t,
                                      symbol: clingo_symbol_t,
                                      iterator: *mut clingo_symbolic_atom_iterator_t)
                                      -> bool;
}
extern "C" {
    /// Check if two iterators point to the same element (or end of the sequence).
    ///
    /// **Parameters:**
    ///
    /// * `atoms` the target
    /// * `a` the first iterator
    /// * `b` the second iterator
    /// * `equal` whether the two iterators are equal
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_symbolic_atoms_iterator_is_equal_to(atoms: *mut clingo_symbolic_atoms_t,
                                                      a: clingo_symbolic_atom_iterator_t,
                                                      b: clingo_symbolic_atom_iterator_t,
                                                      equal: *mut bool)
                                                      -> bool;
}
extern "C" {
    /// Get the symbolic representation of an atom.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` the target
    /// * `iterator` iterator to the atom
    /// * `symbol` the resulting symbol
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_symbolic_atoms_symbol(atoms: *mut clingo_symbolic_atoms_t,
                                        iterator: clingo_symbolic_atom_iterator_t,
                                        symbol: *mut clingo_symbol_t)
                                        -> bool;
}
extern "C" {
    /// Check whether an atom is a fact.
    ///
    ///
    /// **Note:** This does not determine if an atom is a cautious consequence. The
    /// grounding or solving component`s simplifications can only detect this in
    /// some cases.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` the target
    /// * `iterator` iterator to the atom
    /// * `fact` whether the atom is a fact
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_symbolic_atoms_is_fact(atoms: *mut clingo_symbolic_atoms_t,
                                         iterator: clingo_symbolic_atom_iterator_t,
                                         fact: *mut bool)
                                         -> bool;
}
extern "C" {
    /// Check whether an atom is external.
    ///
    /// An atom is external if it has been defined using an external directive and
    /// has not been released or defined by a rule.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` the target
    /// * `iterator` iterator to the atom
    /// * `external` whether the atom is a external
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_symbolic_atoms_is_external(atoms: *mut clingo_symbolic_atoms_t,
                                             iterator: clingo_symbolic_atom_iterator_t,
                                             external: *mut bool)
                                             -> bool;
}
extern "C" {
    /// Returns the (numeric) aspif literal corresponding to the given symbolic atom.
    ///
    /// Such a literal can be mapped to a solver literal (see the \ref Propagator
    /// module) or be used in rules in aspif format (see the \ref ProgramBuilder
    /// module).
    ///
    /// **Parameters:**
    ///
    /// * `atoms` the target
    /// * `iterator` iterator to the atom
    /// * `literal` the associated literal
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_symbolic_atoms_literal(atoms: *mut clingo_symbolic_atoms_t,
                                         iterator: clingo_symbolic_atom_iterator_t,
                                         literal: *mut clingo_literal_t)
                                         -> bool;
}
extern "C" {
    /// Get the number of different predicate signatures used in the program.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` the target
    /// * `size` the number of signatures
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_symbolic_atoms_signatures_size(atoms: *mut clingo_symbolic_atoms_t,
                                                 size: *mut usize)
                                                 -> bool;
}
extern "C" {
    /// Get the predicate signatures occurring in a logic program.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` the target
    /// * `signatures` the resulting signatures
    /// * `size` the number of signatures
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    /// - ::clingo_error_runtime if the size is too small
    ///
    /// @see clingo_symbolic_atoms_signatures_size()
    pub fn clingo_symbolic_atoms_signatures(atoms: *mut clingo_symbolic_atoms_t,
                                            signatures: *mut clingo_signature_t,
                                            size: usize)
                                            -> bool;
}
extern "C" {
    /// Get an iterator to the next element in the sequence of symbolic atoms.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` the target
    /// * `iterator` the current iterator
    /// * `next` the succeeding iterator
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_symbolic_atoms_next(atoms: *mut clingo_symbolic_atoms_t,
                                      iterator: clingo_symbolic_atom_iterator_t,
                                      next: *mut clingo_symbolic_atom_iterator_t)
                                      -> bool;
}
extern "C" {
    /// Check whether the given iterator points to some element with the sequence
    /// of symbolic atoms or to the end of the sequence.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` the target
    /// * `iterator` the iterator
    /// * `valid` whether the iterator points to some element within the
    /// sequence
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_symbolic_atoms_is_valid(atoms: *mut clingo_symbolic_atoms_t,
                                          iterator: clingo_symbolic_atom_iterator_t,
                                          valid: *mut bool)
                                          -> bool;
}
#[repr(u32)]
/// Enumeration of theory term types.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_theory_term_type {
    clingo_theory_term_type_tuple = 0,
    clingo_theory_term_type_list = 1,
    clingo_theory_term_type_set = 2,
    clingo_theory_term_type_function = 3,
    clingo_theory_term_type_number = 4,
    clingo_theory_term_type_symbol = 5,
}
/// Corresponding type to ::clingo_theory_term_type.
pub type clingo_theory_term_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_theory_atoms([u8; 0]);
/// Container that stores theory atoms, elements, and terms (see @ref clingo_control_theory_atoms()).
pub type clingo_theory_atoms_t = clingo_theory_atoms;
extern "C" {
    /// Get the type of the given theory term.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` container where the term is stored
    /// * `term` id of the term
    /// * `type` the resulting type
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_theory_atoms_term_type(atoms: *mut clingo_theory_atoms_t,
                                         term: clingo_id_t,
                                         type_: *mut clingo_theory_term_type_t)
                                         -> bool;
}
extern "C" {
    /// Get the number of the given numeric theory term.
    ///
    /// @pre The term must be of type ::clingo_theory_term_type_number.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` container where the term is stored
    /// * `term` id of the term
    /// * `number` the resulting number
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_theory_atoms_term_number(atoms: *mut clingo_theory_atoms_t,
                                           term: clingo_id_t,
                                           number: *mut ::std::os::raw::c_int)
                                           -> bool;
}
extern "C" {
    /// Get the name of the given constant or function theory term.
    ///
    /// @pre The term must be of type ::clingo_theory_term_type_function or ::clingo_theory_term_type_symbol.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` container where the term is stored
    /// * `term` id of the term
    /// * `name` the resulting name
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_theory_atoms_term_name(atoms: *mut clingo_theory_atoms_t,
                                         term: clingo_id_t,
                                         name: *mut *const ::std::os::raw::c_char)
                                         -> bool;
}
extern "C" {
    /// Get the arguments of the given function theory term.
    ///
    /// @pre The term must be of type ::clingo_theory_term_type_function.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` container where the term is stored
    /// * `term` id of the term
    /// * `arguments` the resulting arguments in form of an array of term ids
    /// * `size` the number of arguments
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_theory_atoms_term_arguments(atoms: *mut clingo_theory_atoms_t,
                                              term: clingo_id_t,
                                              arguments: *mut *const clingo_id_t,
                                              size: *mut usize)
                                              -> bool;
}
extern "C" {
    /// Get the size of the string representation of the given theory term (including the terminating 0).
    ///
    /// **Parameters:**
    ///
    /// * `atoms` container where the term is stored
    /// * `term` id of the term
    /// * `size` the resulting size
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_theory_atoms_term_to_string_size(atoms: *mut clingo_theory_atoms_t,
                                                   term: clingo_id_t,
                                                   size: *mut usize)
                                                   -> bool;
}
extern "C" {
    /// Get the string representation of the given theory term.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` container where the term is stored
    /// * `term` id of the term
    /// * `string` the resulting string
    /// * `size` the size of the string
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_runtime if the size is too small
    /// - ::clingo_error_bad_alloc
    ///
    /// @see clingo_theory_atoms_term_to_string_size()
    pub fn clingo_theory_atoms_term_to_string(atoms: *mut clingo_theory_atoms_t,
                                              term: clingo_id_t,
                                              string: *mut ::std::os::raw::c_char,
                                              size: usize)
                                              -> bool;
}
extern "C" {
    /// Get the tuple (array of theory terms) of the given theory element.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` container where the element is stored
    /// * `element` id of the element
    /// * `tuple` the resulting array of term ids
    /// * `size` the number of term ids
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_theory_atoms_element_tuple(atoms: *mut clingo_theory_atoms_t,
                                             element: clingo_id_t,
                                             tuple: *mut *const clingo_id_t,
                                             size: *mut usize)
                                             -> bool;
}
extern "C" {
    /// Get the condition (array of aspif literals) of the given theory element.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` container where the element is stored
    /// * `element` id of the element
    /// * `condition` the resulting array of aspif literals
    /// * `size` the number of term literals
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_theory_atoms_element_condition(atoms: *mut clingo_theory_atoms_t,
                                                 element: clingo_id_t,
                                                 condition: *mut *const clingo_literal_t,
                                                 size: *mut usize)
                                                 -> bool;
}
extern "C" {
    /// Get the id of the condition of the given theory element.
    ///
    ///
    /// **Note:**
    /// This id can be mapped to a solver literal using clingo_propagate_init_solver_literal().
    /// This id is not (necessarily) an aspif literal;
    /// to get aspif literals use clingo_theory_atoms_element_condition().
    ///
    /// **Parameters:**
    ///
    /// * `atoms` container where the element is stored
    /// * `element` id of the element
    /// * `condition` the resulting condition id
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_theory_atoms_element_condition_id(atoms: *mut clingo_theory_atoms_t,
                                                    element: clingo_id_t,
                                                    condition: *mut clingo_literal_t)
                                                    -> bool;
}
extern "C" {
    /// Get the size of the string representation of the given theory element (including the terminating 0).
    ///
    /// **Parameters:**
    ///
    /// * `atoms` container where the element is stored
    /// * `element` id of the element
    /// * `size` the resulting size
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_theory_atoms_element_to_string_size(atoms: *mut clingo_theory_atoms_t,
                                                      element: clingo_id_t,
                                                      size: *mut usize)
                                                      -> bool;
}
extern "C" {
    /// Get the string representation of the given theory element.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` container where the element is stored
    /// * `element` id of the element
    /// * `string` the resulting string
    /// * `size` the size of the string
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_runtime if the size is too small
    /// - ::clingo_error_bad_alloc
    pub fn clingo_theory_atoms_element_to_string(atoms: *mut clingo_theory_atoms_t,
                                                 element: clingo_id_t,
                                                 string: *mut ::std::os::raw::c_char,
                                                 size: usize)
                                                 -> bool;
}
extern "C" {
    /// Get the total number of theory atoms.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` the target
    /// * `size` the resulting number
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_theory_atoms_size(atoms: *mut clingo_theory_atoms_t, size: *mut usize) -> bool;
}
extern "C" {
    /// Get the theory term associated with the theory atom.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` container where the atom is stored
    /// * `atom` id of the atom
    /// * `term` the resulting term id
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_theory_atoms_atom_term(atoms: *mut clingo_theory_atoms_t,
                                         atom: clingo_id_t,
                                         term: *mut clingo_id_t)
                                         -> bool;
}
extern "C" {
    /// Get the theory elements associated with the theory atom.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` container where the atom is stored
    /// * `atom` id of the atom
    /// * `elements` the resulting array of elements
    /// * `size` the number of elements
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_theory_atoms_atom_elements(atoms: *mut clingo_theory_atoms_t,
                                             atom: clingo_id_t,
                                             elements: *mut *const clingo_id_t,
                                             size: *mut usize)
                                             -> bool;
}
extern "C" {
    /// Whether the theory atom has a guard.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` container where the atom is stored
    /// * `atom` id of the atom
    /// * `has_guard` whether the theory atom has a guard
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_theory_atoms_atom_has_guard(atoms: *mut clingo_theory_atoms_t,
                                              atom: clingo_id_t,
                                              has_guard: *mut bool)
                                              -> bool;
}
extern "C" {
    /// Get the guard consisting of a theory operator and a theory term of the given theory atom.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` container where the atom is stored
    /// * `atom` id of the atom
    /// * `connective` the resulting theory operator
    /// * `term` the resulting term
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_theory_atoms_atom_guard(atoms: *mut clingo_theory_atoms_t,
                                          atom: clingo_id_t,
                                          connective: *mut *const ::std::os::raw::c_char,
                                          term: *mut clingo_id_t)
                                          -> bool;
}
extern "C" {
    /// Get the aspif literal associated with the given theory atom.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` container where the atom is stored
    /// * `atom` id of the atom
    /// * `literal` the resulting literal
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_theory_atoms_atom_literal(atoms: *mut clingo_theory_atoms_t,
                                            atom: clingo_id_t,
                                            literal: *mut clingo_literal_t)
                                            -> bool;
}
extern "C" {
    /// Get the size of the string representation of the given theory atom (including the terminating 0).
    ///
    /// **Parameters:**
    ///
    /// * `atoms` container where the atom is stored
    /// * `atom` id of the element
    /// * `size` the resulting size
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_theory_atoms_atom_to_string_size(atoms: *mut clingo_theory_atoms_t,
                                                   atom: clingo_id_t,
                                                   size: *mut usize)
                                                   -> bool;
}
extern "C" {
    /// Get the string representation of the given theory atom.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` container where the atom is stored
    /// * `atom` id of the element
    /// * `string` the resulting string
    /// * `size` the size of the string
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_runtime if the size is too small
    /// - ::clingo_error_bad_alloc
    pub fn clingo_theory_atoms_atom_to_string(atoms: *mut clingo_theory_atoms_t,
                                              atom: clingo_id_t,
                                              string: *mut ::std::os::raw::c_char,
                                              size: usize)
                                              -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_solve_control([u8; 0]);
/// Object to add clauses during search.
pub type clingo_solve_control_t = clingo_solve_control;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_model([u8; 0]);
/// Object representing a model.
pub type clingo_model_t = clingo_model;
#[repr(u32)]
/// Enumeration for the different model types.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_model_type {
    clingo_model_type_stable_model = 0,
    clingo_model_type_brave_consequences = 1,
    clingo_model_type_cautious_consequences = 2,
}
/// Corresponding type to ::clingo_model_type.
pub type clingo_model_type_t = ::std::os::raw::c_int;
#[repr(u32)]
/// Enumeration of bit flags to select symbols in models.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_show_type {
    clingo_show_type_csp = 1,
    clingo_show_type_shown = 2,
    clingo_show_type_atoms = 4,
    clingo_show_type_terms = 8,
    clingo_show_type_extra = 16,
    clingo_show_type_all = 31,
    clingo_show_type_complement = 32,
}
/// Corresponding type to ::clingo_show_type.
pub type clingo_show_type_bitset_t = ::std::os::raw::c_uint;
extern "C" {
    /// Get the type of the model.
    ///
    /// **Parameters:**
    ///
    /// * `model` the target
    /// * `type` the type of the model
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_model_type(model: *mut clingo_model_t, type_: *mut clingo_model_type_t) -> bool;
}
extern "C" {
    /// Get the running number of the model.
    ///
    /// **Parameters:**
    ///
    /// * `model` the target
    /// * `number` the number of the model
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_model_number(model: *mut clingo_model_t, number: *mut u64) -> bool;
}
extern "C" {
    /// Get the number of symbols of the selected types in the model.
    ///
    /// **Parameters:**
    ///
    /// * `model` the target
    /// * `show` which symbols to select
    /// * `size` the number symbols
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_model_symbols_size(model: *mut clingo_model_t,
                                     show: clingo_show_type_bitset_t,
                                     size: *mut usize)
                                     -> bool;
}
extern "C" {
    /// Get the symbols of the selected types in the model.
    ///
    ///
    /// **Note:** CSP assignments are represented using functions with name "$"
    /// where the first argument is the name of the CSP variable and the second one its
    /// value.
    ///
    /// **Parameters:**
    ///
    /// * `model` the target
    /// * `show` which symbols to select
    /// * `symbols` the resulting symbols
    /// * `size` the number of selected symbols
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    /// - ::clingo_error_runtime if the size is too small
    ///
    /// @see clingo_model_symbols_size()
    pub fn clingo_model_symbols(model: *mut clingo_model_t,
                                show: clingo_show_type_bitset_t,
                                symbols: *mut clingo_symbol_t,
                                size: usize)
                                -> bool;
}
extern "C" {
    /// Constant time lookup to test whether an atom is in a model.
    ///
    /// **Parameters:**
    ///
    /// * `model` the target
    /// * `atom` the atom to lookup
    /// * `contained` whether the atom is contained
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_model_contains(model: *mut clingo_model_t,
                                 atom: clingo_symbol_t,
                                 contained: *mut bool)
                                 -> bool;
}
extern "C" {
    /// Check if a program literal is true in a model.
    ///
    /// **Parameters:**
    ///
    /// * `model` the target
    /// * `literal` the literal to lookup
    /// * `result` whether the literal is true
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_model_is_true(model: *mut clingo_model_t,
                                literal: clingo_literal_t,
                                result: *mut bool)
                                -> bool;
}
extern "C" {
    /// Get the number of cost values of a model.
    ///
    /// **Parameters:**
    ///
    /// * `model` the target
    /// * `size` the number of costs
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_model_cost_size(model: *mut clingo_model_t, size: *mut usize) -> bool;
}
extern "C" {
    /// Get the cost vector of a model.
    ///
    /// **Parameters:**
    ///
    /// * `model` the target
    /// * `costs` the resulting costs
    /// * `size` the number of costs
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    /// - ::clingo_error_runtime if the size is too small
    ///
    /// @see clingo_model_cost_size()
    /// @see clingo_model_optimality_proven()
    pub fn clingo_model_cost(model: *mut clingo_model_t, costs: *mut i64, size: usize) -> bool;
}
extern "C" {
    /// Whether the optimality of a model has been proven.
    ///
    /// **Parameters:**
    ///
    /// * `model` the target
    /// * `proven` whether the optimality has been proven
    ///
    /// **Returns** whether the call was successful
    ///
    /// @see clingo_model_cost()
    pub fn clingo_model_optimality_proven(model: *mut clingo_model_t, proven: *mut bool) -> bool;
}
extern "C" {
    /// Get the id of the solver thread that found the model.
    ///
    /// **Parameters:**
    ///
    /// * `model` the target
    /// * `id` the resulting thread id
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_model_thread_id(model: *mut clingo_model_t, id: *mut clingo_id_t) -> bool;
}
extern "C" {
    /// Get the associated solve control object of a model.
    ///
    /// This object allows for adding clauses during model enumeration.
    ///
    /// **Parameters:**
    ///
    /// * `model` the target
    /// * `control` the resulting solve control object
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_model_context(model: *mut clingo_model_t,
                                control: *mut *mut clingo_solve_control_t)
                                -> bool;
}
extern "C" {
    /// Get an object to inspect the symbolic atoms.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `atoms` the resulting object
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_solve_control_symbolic_atoms(control: *mut clingo_solve_control_t,
                                               atoms: *mut *mut clingo_symbolic_atoms_t)
                                               -> bool;
}
extern "C" {
    /// Add a clause that applies to the current solving step during model
    /// enumeration.
    ///
    ///
    /// **Note:** The @ref Propagator module provides a more sophisticated
    /// interface to add clauses - even on partial assignments.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `clause` array of literals representing the clause
    /// * `size` the size of the literal array
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    /// - ::clingo_error_runtime if adding the clause fails
    pub fn clingo_solve_control_add_clause(control: *mut clingo_solve_control_t,
                                           clause: *const clingo_literal_t,
                                           size: usize)
                                           -> bool;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_solve_result {
    clingo_solve_result_satisfiable = 1,
    clingo_solve_result_unsatisfiable = 2,
    clingo_solve_result_exhausted = 4,
    clingo_solve_result_interrupted = 8,
}
pub type clingo_solve_result_bitset_t = ::std::os::raw::c_uint;
#[repr(u32)]
/// Enumeration of solve modes.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_solve_mode {
    clingo_solve_mode_async = 1,
    clingo_solve_mode_yield = 2,
}
/// Corresponding type to ::clingo_solve_mode.
pub type clingo_solve_mode_bitset_t = ::std::os::raw::c_uint;
#[repr(u32)]
/// Enumeration of solve events.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_solve_event_type {
    clingo_solve_event_type_model = 0,
    clingo_solve_event_type_finish = 1,
}
/// Corresponding type to ::clingo_solve_event_type.
pub type clingo_solve_event_type_t = ::std::os::raw::c_uint;
/// Callback function called during search to notify when the search is finished or a model is ready.
///
/// If a (non-recoverable) clingo API function fails in this callback, it must return false.
/// In case of errors not related to clingo, set error code ::clingo_error_unknown and return false to stop solving with an error.
///
/// @attention If the search is finished, the model is NULL.
///
/// **Parameters:**
///
/// * `model` the current model
/// * `data` user data of the callback
/// * `goon` can be set to false to stop solving
///
/// **Returns** whether the call was successful
///
/// @see clingo_control_solve()
pub type clingo_solve_event_callback_t =
    ::std::option::Option<unsafe extern "C" fn(type_: clingo_solve_event_type_t,
                                                 event: *mut ::std::os::raw::c_void,
                                                 data: *mut ::std::os::raw::c_void,
                                                 goon: *mut bool)
                                                 -> bool>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_solve_handle([u8; 0]);
/// Search handle to a solve call.
///
/// @see clingo_control_solve()
pub type clingo_solve_handle_t = clingo_solve_handle;
extern "C" {
    /// Get the next solve result.
    ///
    /// Blocks until the result is ready.
    /// When yielding partial solve results can be obtained, i.e.,
    /// when a model is ready, the result will be satisfiable but neither the search exhausted nor the optimality proven.
    ///
    /// **Parameters:**
    ///
    /// * `handle` the target
    /// * `result` the solve result
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    /// - ::clingo_error_runtime if solving fails
    pub fn clingo_solve_handle_get(handle: *mut clingo_solve_handle_t,
                                   result: *mut clingo_solve_result_bitset_t)
                                   -> bool;
}
extern "C" {
    /// Wait for the specified amount of time to check if the next result is ready.
    ///
    /// If the time is set to zero, this function can be used to poll if the search is still active.
    /// If the time is negative, the function blocks until the search is finished.
    ///
    /// **Parameters:**
    ///
    /// * `handle` the target
    /// * `timeout` the maximum time to wait
    /// * `result` whether the search has finished
    pub fn clingo_solve_handle_wait(handle: *mut clingo_solve_handle_t,
                                    timeout: f64,
                                    result: *mut bool);
}
extern "C" {
    /// Get the next model (or zero if there are no more models).
    ///
    /// **Parameters:**
    ///
    /// * `handle` the target
    /// * `model` the model (it is NULL if there are no more models)
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    /// - ::clingo_error_runtime if solving fails
    pub fn clingo_solve_handle_model(handle: *mut clingo_solve_handle_t,
                                     model: *mut *mut clingo_model_t)
                                     -> bool;
}
extern "C" {
    /// Discards the last model and starts the search for the next one.
    ///
    /// If the search has been started asynchronously, this function continues the search in the background.
    ///
    ///
    /// **Note:** This function does not block.
    ///
    /// **Parameters:**
    ///
    /// * `handle` the target
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    /// - ::clingo_error_runtime if solving fails
    pub fn clingo_solve_handle_resume(handle: *mut clingo_solve_handle_t) -> bool;
}
extern "C" {
    /// Stop the running search and block until done.
    ///
    /// **Parameters:**
    ///
    /// * `handle` the target
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    /// - ::clingo_error_runtime if solving fails
    pub fn clingo_solve_handle_cancel(handle: *mut clingo_solve_handle_t) -> bool;
}
extern "C" {
    /// Stops the running search and releases the handle.
    ///
    /// Blocks until the search is stopped (as if an implicit cancel was called before the handle is released).
    ///
    /// **Parameters:**
    ///
    /// * `handle` the target
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    /// - ::clingo_error_runtime if solving fails
    pub fn clingo_solve_handle_close(handle: *mut clingo_solve_handle_t) -> bool;
}
#[repr(u32)]
/// Supported check modes for propagators.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_propagator_check_mode {
    clingo_propagator_check_mode_none = 0,
    clingo_propagator_check_mode_total = 1,
    clingo_propagator_check_mode_fixpoint = 2,
}
/// Corresponding type to ::clingo_propagator_check_mode.
pub type clingo_propagator_check_mode_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_propagate_init([u8; 0]);
/// Object to initialize a user-defined propagator before each solving step.
///
/// Each @link SymbolicAtoms symbolic@endlink or @link TheoryAtoms theory atom@endlink is uniquely associated with an aspif atom in form of a positive integer (@ref ::clingo_literal_t).
/// Aspif literals additionally are signed to represent default negation.
/// Furthermore, there are non-zero integer solver literals (also represented using @ref ::clingo_literal_t).
/// There is a surjective mapping from program atoms to solver literals.
///
/// All methods called during propagation use solver literals whereas clingo_symbolic_atoms_literal() and clingo_theory_atoms_atom_literal() return program literals.
/// The function clingo_propagate_init_solver_literal() can be used to map program literals or @link clingo_theory_atoms_element_condition_id() condition ids@endlink to solver literals.
pub type clingo_propagate_init_t = clingo_propagate_init;
extern "C" {
    /// Map the given program literal or condition id to its solver literal.
    ///
    /// **Parameters:**
    ///
    /// * `init` the target
    /// * `aspif_literal` the aspif literal to map
    /// * `solver_literal` the resulting solver literal
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_propagate_init_solver_literal(init: *mut clingo_propagate_init_t,
                                                aspif_literal: clingo_literal_t,
                                                solver_literal: *mut clingo_literal_t)
                                                -> bool;
}
extern "C" {
    /// Add a watch for the solver literal in the given phase.
    ///
    /// **Parameters:**
    ///
    /// * `init` the target
    /// * `solver_literal` the solver literal
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_propagate_init_add_watch(init: *mut clingo_propagate_init_t,
                                           solver_literal: clingo_literal_t)
                                           -> bool;
}
extern "C" {
    /// Get an object to inspect the symbolic atoms.
    ///
    /// **Parameters:**
    ///
    /// * `init` the target
    /// * `atoms` the resulting object
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_propagate_init_symbolic_atoms(init: *mut clingo_propagate_init_t,
                                                atoms: *mut *mut clingo_symbolic_atoms_t)
                                                -> bool;
}
extern "C" {
    /// Get an object to inspect the theory atoms.
    ///
    /// **Parameters:**
    ///
    /// * `init` the target
    /// * `atoms` the resulting object
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_propagate_init_theory_atoms(init: *mut clingo_propagate_init_t,
                                              atoms: *mut *mut clingo_theory_atoms_t)
                                              -> bool;
}
extern "C" {
    /// Get the number of threads used in subsequent solving.
    ///
    /// **Parameters:**
    ///
    /// * `init` the target
    ///
    /// **Returns** the number of threads
    /// @see clingo_propagate_control_thread_id()
    pub fn clingo_propagate_init_number_of_threads(init: *mut clingo_propagate_init_t)
                                                   -> ::std::os::raw::c_int;
}
extern "C" {
    /// Configure when to call the check method of the propagator.
    ///
    /// **Parameters:**
    ///
    /// * `init` - the target
    /// *`mode`- bitmask when to call the propagator
    /// @see @ref ::clingo_propagator::check()
    pub fn clingo_propagate_init_set_check_mode(init: *mut clingo_propagate_init_t,
                                                mode: clingo_propagator_check_mode_t);
}
extern "C" {
    /// Get the current check mode of the propagator.
    ///
    /// **Parameters:**
    ///
    /// * `init`- the target
    ///
    /// **Returns**  bitmask when to call the propagator
    /// @see clingo_propagate_init_set_check_mode()
    pub fn clingo_propagate_init_get_check_mode(init: *mut clingo_propagate_init_t)
                                                -> clingo_propagator_check_mode_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_assignment([u8; 0]);
/// Represents a (partial) assignment of a particular solver.
///
/// An assignment assigns truth values to a set of literals.
/// A literal is assigned to either @link clingo_assignment_truth_value() true or false, or is unassigned@endlink.
/// Furthermore, each assigned literal is associated with a @link clingo_assignment_level() decision level@endlink.
/// There is exactly one @link clingo_assignment_decision() decision literal@endlink for each decision level greater than zero.
/// Assignments to all other literals on the same level are consequences implied by the current and possibly previous decisions.
/// Assignments on level zero are immediate consequences of the current program.
/// Decision levels are consecutive numbers starting with zero up to and including the @link clingo_assignment_decision_level() current decision level@endlink.
pub type clingo_assignment_t = clingo_assignment;
extern "C" {
    /// Get the current decision level.
    ///
    /// **Parameters:**
    ///
    /// * `assignment` the target assignment
    ///
    /// **Returns** the decision level
    pub fn clingo_assignment_decision_level(assignment: *mut clingo_assignment_t) -> u32;
}
extern "C" {
    /// Check if the given assignment is conflicting.
    ///
    /// **Parameters:**
    ///
    /// * `assignment` the target assignment
    ///
    /// **Returns** whether the assignment is conflicting
    pub fn clingo_assignment_has_conflict(assignment: *mut clingo_assignment_t) -> bool;
}
extern "C" {
    /// Check if the given literal is part of a (partial) assignment.
    ///
    /// **Parameters:**
    ///
    /// * `assignment` the target assignment
    /// * `literal` the literal
    ///
    /// **Returns** whether the literal is valid
    pub fn clingo_assignment_has_literal(assignment: *mut clingo_assignment_t,
                                         literal: clingo_literal_t)
                                         -> bool;
}
extern "C" {
    /// Determine the decision level of a given literal.
    ///
    /// **Parameters:**
    ///
    /// * `assignment` the target assignment
    /// * `literal` the literal
    /// * `level` the resulting level
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_assignment_level(assignment: *mut clingo_assignment_t,
                                   literal: clingo_literal_t,
                                   level: *mut u32)
                                   -> bool;
}
extern "C" {
    /// Determine the decision literal given a decision level.
    ///
    /// **Parameters:**
    ///
    /// * `assignment` the target assignment
    /// * `level` the level
    /// * `literal` the resulting literal
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_assignment_decision(assignment: *mut clingo_assignment_t,
                                      level: u32,
                                      literal: *mut clingo_literal_t)
                                      -> bool;
}
extern "C" {
    /// Check if a literal has a fixed truth value.
    ///
    /// **Parameters:**
    ///
    /// * `assignment` the target assignment
    /// * `literal` the literal
    /// * `is_fixed` whether the literal is fixed
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_assignment_is_fixed(assignment: *mut clingo_assignment_t,
                                      literal: clingo_literal_t,
                                      is_fixed: *mut bool)
                                      -> bool;
}
extern "C" {
    /// Check if a literal is true.
    ///
    /// **Parameters:**
    ///
    /// * `assignment` the target assignment
    /// * `literal` the literal
    /// * `is_true` whether the literal is true
    ///
    /// **Returns** whether the call was successful
    /// @see clingo_assignment_truth_value()
    pub fn clingo_assignment_is_true(assignment: *mut clingo_assignment_t,
                                     literal: clingo_literal_t,
                                     is_true: *mut bool)
                                     -> bool;
}
extern "C" {
    /// Check if a literal has a fixed truth value.
    ///
    /// **Parameters:**
    ///
    /// * `assignment` the target assignment
    /// * `literal` the literal
    /// * `is_false` whether the literal is false
    ///
    /// **Returns** whether the call was successful
    /// @see clingo_assignment_truth_value()
    pub fn clingo_assignment_is_false(assignment: *mut clingo_assignment_t,
                                      literal: clingo_literal_t,
                                      is_false: *mut bool)
                                      -> bool;
}
extern "C" {
    /// Determine the truth value of a given literal.
    ///
    /// **Parameters:**
    ///
    /// * `assignment` - the target assignment
    /// * `literal` - the literal
    /// * `value` - the resulting truth value
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_assignment_truth_value(assignment: *mut clingo_assignment_t,
                                         literal: clingo_literal_t,
                                         value: *mut clingo_truth_value_t)
                                         -> bool;
}
extern "C" {
    /// The number of assigned literals in the assignment.
    /// **Parameters:**
    ///
    /// * `assignment`- the target
    ///
    /// **Returns** the number of literals
    pub fn clingo_assignment_size(assignment: *mut clingo_assignment_t) -> usize;
}
extern "C" {
    /// The maximum size of the assignment (if all literals are assigned).
    ///
    /// **Parameters:**
    ///
    /// * `assignment`- the target
    ///
    /// **Returns** the maximum size
    pub fn clingo_assignment_max_size(assignment: *mut clingo_assignment_t) -> usize;
}
extern "C" {
    /// Check if the assignmen is total, i.e. - size == max_size.
    ///
    /// **Parameters:**
    ///
    /// * `assignment`- the target
    ///
    /// **Returns** wheather the assignment is total
    pub fn clingo_assignment_is_total(assignment: *mut clingo_assignment_t) -> bool;
}
#[repr(u32)]
/// Enumeration of clause types determining the lifetime of a clause.
///
/// Clauses in the solver are either cleaned up based on a configurable deletion policy or at the end of a solving step.
/// The values of this enumeration determine if a clause is subject to one of the above deletion strategies.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_clause_type {
    clingo_clause_type_learnt = 0,
    clingo_clause_type_static = 1,
    clingo_clause_type_volatile = 2,
    clingo_clause_type_volatile_static = 3,
}
/// Corresponding type to ::clingo_clause_type.
pub type clingo_clause_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_propagate_control([u8; 0]);
/// This object can be used to add clauses and propagate literals while solving.
pub type clingo_propagate_control_t = clingo_propagate_control;
extern "C" {
    /// Get the id of the underlying solver thread.
    ///
    /// Thread ids are consecutive numbers starting with zero.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    ///
    /// **Returns** the thread id
    pub fn clingo_propagate_control_thread_id(control: *mut clingo_propagate_control_t)
                                              -> clingo_id_t;
}
extern "C" {
    /// Get the assignment associated with the underlying solver.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    ///
    /// **Returns** the assignment
    pub fn clingo_propagate_control_assignment(control: *mut clingo_propagate_control_t)
                                               -> *mut clingo_assignment_t;
}
extern "C" {
    /// Adds a new volatile literal to the underlying solver thread.
    ///
    /// @attention The literal is only valid within the current solving step and solver thread.
    /// All volatile literals and clauses involving a volatile literal are deleted after the current search.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `result` the (positive) solver literal
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    /// - ::clingo_error_logic if the assignment is conflicting
    pub fn clingo_propagate_control_add_literal(control: *mut clingo_propagate_control_t,
                                                result: *mut clingo_literal_t)
                                                -> bool;
}
extern "C" {
    /// Add a watch for the solver literal in the given phase.
    ///
    ///
    /// **Note:** Unlike @ref clingo_propagate_init_add_watch() this does not add a watch to all solver threads but just the current one.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `literal` the literal to watch
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    /// - ::clingo_error_logic if the literal is invalid
    /// @see clingo_propagate_control_remove_watch()
    pub fn clingo_propagate_control_add_watch(control: *mut clingo_propagate_control_t,
                                              literal: clingo_literal_t)
                                              -> bool;
}
extern "C" {
    /// Check whether a literal is watched in the current solver thread.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `literal` the literal to check
    ///
    ///
    /// **Returns** whether the literal is watched
    pub fn clingo_propagate_control_has_watch(control: *mut clingo_propagate_control_t,
                                              literal: clingo_literal_t)
                                              -> bool;
}
extern "C" {
    /// Removes the watch (if any) for the given solver literal.
    ///
    ///
    /// **Note:** Similar to @ref clingo_propagate_init_add_watch() this just removes the watch in the current solver thread.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `literal` the literal to remove
    pub fn clingo_propagate_control_remove_watch(control: *mut clingo_propagate_control_t,
                                                 literal: clingo_literal_t);
}
extern "C" {
    /// Add the given clause to the solver.
    ///
    /// This method sets its result to false if the current propagation must be stopped for the solver to backtrack.
    ///
    /// @attention No further calls on the control object or functions on the assignment should be called when the result of this method is false.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `clause` the clause to add
    /// * `size` the size of the clause
    /// * `type` the clause type determining its lifetime
    /// * `result` result indicating whether propagation has to be stopped
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_propagate_control_add_clause(control: *mut clingo_propagate_control_t,
                                               clause: *const clingo_literal_t,
                                               size: usize,
                                               type_: clingo_clause_type_t,
                                               result: *mut bool)
                                               -> bool;
}
extern "C" {
    /// Propagate implied literals (resulting from added clauses).
    ///
    /// This method sets its result to false if the current propagation must be stopped for the solver to backtrack.
    ///
    /// @attention No further calls on the control object or functions on the assignment should be called when the result of this method is false.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `result` result indicating whether propagation has to be stopped
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_propagate_control_propagate(control: *mut clingo_propagate_control_t,
                                              result: *mut bool)
                                              -> bool;
}
/// Typedef for @ref ::clingo_propagator::init().
pub type clingo_propagator_init_callback_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut clingo_propagate_init_t,
                                                 arg2: *mut ::std::os::raw::c_void)
                                                 -> bool>;
/// Typedef for @ref ::clingo_propagator::propagate().
pub type clingo_propagator_propagate_callback_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut clingo_propagate_control_t,
                                                 arg2: *const clingo_literal_t,
                                                 arg3: usize,
                                                 arg4: *mut ::std::os::raw::c_void)
                                                 -> bool>;
/// Typedef for @ref ::clingo_propagator::undo().
pub type clingo_propagator_undo_callback_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut clingo_propagate_control_t,
                                                 arg2: *const clingo_literal_t,
                                                 arg3: usize,
                                                 arg4: *mut ::std::os::raw::c_void)
                                                 -> bool>;
/// Typedef for @ref ::clingo_propagator::check().
pub type clingo_propagator_check_callback_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut clingo_propagate_control_t,
                                                 arg2: *mut ::std::os::raw::c_void)
                                                 -> bool>;
/// An instance of this struct has to be registered with a solver to implement a custom propagator.
///
/// Not all callbacks have to be implemented and can be set to NULL if not needed.
/// @see Propagator
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_propagator {
    /// This function is called once before each solving step.
    /// It is used to map relevant program literals to solver literals, add watches for solver literals, and initialize the data structures used during propagation.
    ///
    /// **Note:** This is the last point to access symbolic and theory atoms.
    /// Once the search has started, they are no longer accessible.
    ///
    /// **Parameters:**
    ///
    /// * `init` initizialization object
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    /// @see ::clingo_propagator_init_callback_t
    pub init: ::std::option::Option<unsafe extern "C" fn(init:
                                                             *mut clingo_propagate_init_t,
                                                         data:
                                                             *mut ::std::os::raw::c_void)
                                        -> bool>,
    /// Can be used to propagate solver literals given a @link clingo_assignment_t partial assignment@endlink.
    ///
    /// Called during propagation with a non-empty array of @link clingo_propagate_init_add_watch() watched solver literals@endlink
    /// that have been assigned to true since the last call to either propagate, undo, (or the start of the search) - the change set.
    /// Only watched solver literals are contained in the change set.
    /// Each literal in the change set is true w.r.t. the current @link clingo_assignment_t assignment@endlink.
    /// @ref clingo_propagate_control_add_clause() can be used to add clauses.
    /// If a clause is unit resulting, it can be propagated using @ref clingo_propagate_control_propagate().
    /// If the result of either of the two methods is false, the propagate function must return immediately.
    ///
    /// The following snippet shows how to use the methods to add clauses and propagate consequences within the callback.
    /// The important point is to return true (true to indicate there was no error) if the result of either of the methods is false.
    /// ~~~~~~~~~~~~~~~{.c}
    /// bool result;
    /// clingo_literal_t clause[] = { ... };
    ///
    /// // add a clause
    /// if (!clingo_propagate_control_add_clause(control, clause, clingo_clause_type_learnt, &result) { return false; }
    /// if (!result) { return true; }
    /// // propagate its consequences
    /// if (!clingo_propagate_control_propagate(control, &result) { return false; }
    /// if (!result) { return true; }
    ///
    /// // add further clauses and propagate them
    /// ...
    ///
    /// return true;
    /// ~~~~~~~~~~~~~~~
    ///
    /// **Note:**
    /// This function can be called from different solving threads.
    /// Each thread has its own assignment and id, which can be obtained using @ref clingo_propagate_control_thread_id().
    ///
    /// **Parameters:**
    ///
    /// * `control` control object for the target solver
    /// * `changes` the change set
    /// * `size` the size of the change set
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    /// @see ::clingo_propagator_propagate_callback_t
    pub propagate: ::std::option::Option<unsafe extern "C" fn(control:
                                                                  *mut clingo_propagate_control_t,
                                                              changes:
                                                                  *const clingo_literal_t,
                                                              size: usize,
                                                              data:
                                                                  *mut ::std::os::raw::c_void)
                                             -> bool>,
    /// Called whenever a solver undoes assignments to watched solver literals.
    ///
    /// This callback is meant to update assignment dependent state in the propagator.
    ///
    /// **Note:** No clauses must be propagated in this callback.
    ///
    /// **Parameters:**
    ///
    /// * `control` control object for the target solver
    /// * `changes` the change set
    /// * `size` the size of the change set
    /// * `data` user data for the callback
    /// @see ::clingo_propagator_undo_callback_t
    pub undo: ::std::option::Option<unsafe extern "C" fn(control:
                                                             *mut clingo_propagate_control_t,
                                                         changes:
                                                             *const clingo_literal_t,
                                                         size: usize,
                                                         data:
                                                             *mut ::std::os::raw::c_void)
                                        -> bool>,
    /// This function is similar to @ref clingo_propagate_control_propagate() but is only called on total assignments without a change set.
    ///
    /// **Note:** This function is called even if no watches have been added.
    ///
    /// **Parameters:**
    ///
    /// * `control` control object for the target solver
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    /// @see ::clingo_propagator_check_callback_t
    pub check: ::std::option::Option<unsafe extern "C" fn(control:
                                                              *mut clingo_propagate_control_t,
                                                          data:
                                                              *mut ::std::os::raw::c_void)
                                         -> bool>,
}
#[test]
fn bindgen_test_layout_clingo_propagator() {
    assert_eq!(::std::mem::size_of::<clingo_propagator>(),
               32usize,
               concat!("Size of: ", stringify!(clingo_propagator)));
    assert_eq!(::std::mem::align_of::<clingo_propagator>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_propagator)));
    assert_eq!(unsafe { &(*(0 as *const clingo_propagator)).init as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_propagator),
                       "::",
                       stringify!(init)));
    assert_eq!(unsafe { &(*(0 as *const clingo_propagator)).propagate as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_propagator),
                       "::",
                       stringify!(propagate)));
    assert_eq!(unsafe { &(*(0 as *const clingo_propagator)).undo as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_propagator),
                       "::",
                       stringify!(undo)));
    assert_eq!(unsafe { &(*(0 as *const clingo_propagator)).check as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_propagator),
                       "::",
                       stringify!(check)));
}
impl Clone for clingo_propagator {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_propagator_t = clingo_propagator;
#[repr(u32)]
/// Enumeration of different heuristic modifiers.
/// @ingroup ProgramInspection
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_heuristic_type {
    clingo_heuristic_type_level = 0,
    clingo_heuristic_type_sign = 1,
    clingo_heuristic_type_factor = 2,
    clingo_heuristic_type_init = 3,
    clingo_heuristic_type_true = 4,
    clingo_heuristic_type_false = 5,
}
/// Corresponding type to ::clingo_heuristic_type.
/// @ingroup ProgramInspection
pub type clingo_heuristic_type_t = ::std::os::raw::c_int;
#[repr(u32)]
/// Enumeration of different external statements.
/// @ingroup ProgramInspection
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_external_type {
    clingo_external_type_free = 0,
    clingo_external_type_true = 1,
    clingo_external_type_false = 2,
    clingo_external_type_release = 3,
}
/// Corresponding type to ::clingo_external_type.
/// @ingroup ProgramInspection
pub type clingo_external_type_t = ::std::os::raw::c_int;
/// A Literal with an associated weight.
/// @ingroup ProgramInspection
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_weighted_literal {
    pub literal: clingo_literal_t,
    pub weight: clingo_weight_t,
}
#[test]
fn bindgen_test_layout_clingo_weighted_literal() {
    assert_eq!(::std::mem::size_of::<clingo_weighted_literal>(),
               8usize,
               concat!("Size of: ", stringify!(clingo_weighted_literal)));
    assert_eq!(::std::mem::align_of::<clingo_weighted_literal>(),
               4usize,
               concat!("Alignment of ", stringify!(clingo_weighted_literal)));
    assert_eq!(unsafe { &(*(0 as *const clingo_weighted_literal)).literal as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_weighted_literal),
                       "::",
                       stringify!(literal)));
    assert_eq!(unsafe { &(*(0 as *const clingo_weighted_literal)).weight as *const _ as usize },
               4usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_weighted_literal),
                       "::",
                       stringify!(weight)));
}
impl Clone for clingo_weighted_literal {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_weighted_literal_t = clingo_weighted_literal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_backend([u8; 0]);
/// Handle to the backend to add directives in aspif format.
pub type clingo_backend_t = clingo_backend;
extern "C" {
    /// Add a rule to the program.
    ///
    /// **Parameters:**
    ///
    /// * `backend` the target backend
    /// * `choice` determines if the head is a choice or a disjunction
    /// * `head` the head atoms
    /// * `head_size` the number of atoms in the head
    /// * `body` the body literals
    /// * `body_size` the number of literals in the body
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_backend_rule(backend: *mut clingo_backend_t,
                               choice: bool,
                               head: *const clingo_atom_t,
                               head_size: usize,
                               body: *const clingo_literal_t,
                               body_size: usize)
                               -> bool;
}
extern "C" {
    /// Add a weight rule to the program.
    ///
    /// @attention All weights and the lower bound must be positive.
    ///
    /// **Parameters:**
    ///
    /// * `backend` the target backend
    /// * `choice` determines if the head is a choice or a disjunction
    /// * `head` the head atoms
    /// * `head_size` the number of atoms in the head
    /// * `lower_bound` the lower bound of the weight rule
    /// * `body` the weighted body literals
    /// * `body_size` the number of weighted literals in the body
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_backend_weight_rule(backend: *mut clingo_backend_t,
                                      choice: bool,
                                      head: *const clingo_atom_t,
                                      head_size: usize,
                                      lower_bound: clingo_weight_t,
                                      body: *const clingo_weighted_literal_t,
                                      body_size: usize)
                                      -> bool;
}
extern "C" {
    /// Add a minimize constraint (or weak constraint) to the program.
    ///
    /// **Parameters:**
    ///
    /// * `backend` the target backend
    /// * `priority` the priority of the constraint
    /// * `literals` the weighted literals whose sum to minimize
    /// * `size` the number of weighted literals
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_backend_minimize(backend: *mut clingo_backend_t,
                                   priority: clingo_weight_t,
                                   literals: *const clingo_weighted_literal_t,
                                   size: usize)
                                   -> bool;
}
extern "C" {
    /// Add a projection directive.
    ///
    /// **Parameters:**
    ///
    /// * `backend` the target backend
    /// * `atoms` the atoms to project on
    /// * `size` the number of atoms
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_backend_project(backend: *mut clingo_backend_t,
                                  atoms: *const clingo_atom_t,
                                  size: usize)
                                  -> bool;
}
extern "C" {
    /// Add an external statement.
    ///
    /// **Parameters:**
    ///
    /// * `backend` the target backend
    /// * `atom` the external atom
    /// * `type` the type of the external statement
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_backend_external(backend: *mut clingo_backend_t,
                                   atom: clingo_atom_t,
                                   type_: clingo_external_type_t)
                                   -> bool;
}
extern "C" {
    /// Add an assumption directive.
    ///
    /// **Parameters:**
    ///
    /// * `backend` the target backend
    /// * `literals` the literals to assume (positive literals are true and negative literals false for the next solve call)
    /// * `size` the number of atoms
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_backend_assume(backend: *mut clingo_backend_t,
                                 literals: *const clingo_literal_t,
                                 size: usize)
                                 -> bool;
}
extern "C" {
    /// Add an heuristic directive.
    ///
    /// **Parameters:**
    ///
    /// * `backend` the target backend
    /// * `atom` the target atom
    /// * `type` the type of the heuristic modification
    /// * `bias` the heuristic bias
    /// * `priority` the heuristic priority
    /// * `condition` the condition under which to apply the heuristic modification
    /// * `size` the number of atoms in the condition
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_backend_heuristic(backend: *mut clingo_backend_t,
                                    atom: clingo_atom_t,
                                    type_: clingo_heuristic_type_t,
                                    bias: ::std::os::raw::c_int,
                                    priority: ::std::os::raw::c_uint,
                                    condition: *const clingo_literal_t,
                                    size: usize)
                                    -> bool;
}
extern "C" {
    /// Add an edge directive.
    ///
    /// **Parameters:**
    ///
    /// * `backend` the target backend
    /// * `node_u` the start vertex of the edge
    /// * `node_v` the end vertex of the edge
    /// * `condition` the condition under which the edge is part of the graph
    /// * `size` the number of atoms in the condition
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_backend_acyc_edge(backend: *mut clingo_backend_t,
                                    node_u: ::std::os::raw::c_int,
                                    node_v: ::std::os::raw::c_int,
                                    condition: *const clingo_literal_t,
                                    size: usize)
                                    -> bool;
}
extern "C" {
    /// Get a fresh atom to be used in aspif directives.
    ///
    /// **Parameters:**
    ///
    /// * `backend` the target backend
    /// * `atom` the resulting atom
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_backend_add_atom(backend: *mut clingo_backend_t,
                                   atom: *mut clingo_atom_t)
                                   -> bool;
}
#[repr(u32)]
/// Enumeration for entries of the configuration.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_configuration_type {
    clingo_configuration_type_value = 1,
    clingo_configuration_type_array = 2,
    clingo_configuration_type_map = 4,
}
/// Bitset for values of type ::clingo_configuration_type.
pub type clingo_configuration_type_bitset_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_configuration([u8; 0]);
/// Handle for to the solver configuration.
pub type clingo_configuration_t = clingo_configuration;
extern "C" {
    /// Get the root key of the configuration.
    ///
    /// **Parameters:**
    ///
    /// * `configuration` the target configuration
    /// * `key` the root key
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_configuration_root(configuration: *mut clingo_configuration_t,
                                     key: *mut clingo_id_t)
                                     -> bool;
}
extern "C" {
    /// Get the type of a key.
    ///
    ///
    /// **Note:** The type is bitset, an entry can have multiple (but at least one) type.
    ///
    /// **Parameters:**
    ///
    /// * `configuration` the target configuration
    /// * `key` the key
    /// * `type` the resulting type
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_configuration_type(configuration: *mut clingo_configuration_t,
                                     key: clingo_id_t,
                                     type_: *mut clingo_configuration_type_bitset_t)
                                     -> bool;
}
extern "C" {
    /// Get the description of an entry.
    ///
    /// **Parameters:**
    ///
    /// * `configuration` the target configuration
    /// * `key` the key
    /// * `description` the description
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_configuration_description(configuration: *mut clingo_configuration_t,
                                            key: clingo_id_t,
                                            description: *mut *const ::std::os::raw::c_char)
                                            -> bool;
}
extern "C" {
    /// Get the size of an array entry.
    ///
    /// @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_array.
    ///
    /// **Parameters:**
    ///
    /// * `configuration` the target configuration
    /// * `key` the key
    /// * `size` the resulting size
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_configuration_array_size(configuration: *mut clingo_configuration_t,
                                           key: clingo_id_t,
                                           size: *mut usize)
                                           -> bool;
}
extern "C" {
    /// Get the subkey at the given offset of an array entry.
    ///
    ///
    /// **Note:** Some array entries, like fore example the solver configuration, can be accessed past there actual size to add subentries.
    /// @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_array.
    ///
    /// **Parameters:**
    ///
    /// * `configuration` the target configuration
    /// * `key` the key
    /// * `offset` the offset in the array
    /// * `subkey` the resulting subkey
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_configuration_array_at(configuration: *mut clingo_configuration_t,
                                         key: clingo_id_t,
                                         offset: usize,
                                         subkey: *mut clingo_id_t)
                                         -> bool;
}
extern "C" {
    /// Get the number of subkeys of a map entry.
    ///
    /// @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_map.
    ///
    /// **Parameters:**
    ///
    /// * `configuration` the target configuration
    /// * `key` the key
    /// * `size` the resulting number
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_configuration_map_size(configuration: *mut clingo_configuration_t,
                                         key: clingo_id_t,
                                         size: *mut usize)
                                         -> bool;
}
extern "C" {
    /// Query whether the map has a key.
    ///
    /// @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_map.
    ///
    /// **Note:** Multiple levels can be looked up by concatenating keys with a period.
    ///
    /// **Parameters:**
    ///
    /// * `configuration` the target configuration
    /// * `key` the key
    /// * `name` the name to lookup the subkey
    /// * `result` whether the key is in the map
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_configuration_map_has_subkey(configuration: *mut clingo_configuration_t,
                                               key: clingo_id_t,
                                               name: *const ::std::os::raw::c_char,
                                               result: *mut bool)
                                               -> bool;
}
extern "C" {
    /// Get the name associated with the offset-th subkey.
    ///
    /// @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_map.
    ///
    /// **Parameters:**
    ///
    /// * `configuration` the target configuration
    /// * `key` the key
    /// * `offset` the offset of the name
    /// * `name` the resulting name
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_configuration_map_subkey_name(configuration: *mut clingo_configuration_t,
                                                key: clingo_id_t,
                                                offset: usize,
                                                name: *mut *const ::std::os::raw::c_char)
                                                -> bool;
}
extern "C" {
    /// Lookup a subkey under the given name.
    ///
    /// @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_map.
    ///
    /// **Note:** Multiple levels can be looked up by concatenating keys with a period.
    ///
    /// **Parameters:**
    ///
    /// * `configuration` the target configuration
    /// * `key` the key
    /// * `name` the name to lookup the subkey
    /// * `subkey` the resulting subkey
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_configuration_map_at(configuration: *mut clingo_configuration_t,
                                       key: clingo_id_t,
                                       name: *const ::std::os::raw::c_char,
                                       subkey: *mut clingo_id_t)
                                       -> bool;
}
extern "C" {
    /// Check whether a entry has a value.
    ///
    /// @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_value.
    ///
    /// **Parameters:**
    ///
    /// * `configuration` the target configuration
    /// * `key` the key
    /// * `assigned` whether the entry has a value
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_configuration_value_is_assigned(configuration: *mut clingo_configuration_t,
                                                  key: clingo_id_t,
                                                  assigned: *mut bool)
                                                  -> bool;
}
extern "C" {
    /// Get the size of the string value of the given entry.
    ///
    /// @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_value.
    ///
    /// **Parameters:**
    ///
    /// * `configuration` the target configuration
    /// * `key` the key
    /// * `size` the resulting size
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_configuration_value_get_size(configuration: *mut clingo_configuration_t,
                                               key: clingo_id_t,
                                               size: *mut usize)
                                               -> bool;
}
extern "C" {
    /// Get the string value of the given entry.
    ///
    /// @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_value.
    /// @pre The given size must be larger or equal to size of the value.
    ///
    /// **Parameters:**
    ///
    /// * `configuration` the target configuration
    /// * `key` the key
    /// * `value` the resulting string value
    /// * `size` the size of the given char array
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_configuration_value_get(configuration: *mut clingo_configuration_t,
                                          key: clingo_id_t,
                                          value: *mut ::std::os::raw::c_char,
                                          size: usize)
                                          -> bool;
}
extern "C" {
    /// Set the value of an entry.
    ///
    /// @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_value.
    ///
    /// **Parameters:**
    ///
    /// * `configuration` the target configuration
    /// * `key` the key
    /// * `value` the value to set
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_configuration_value_set(configuration: *mut clingo_configuration_t,
                                          key: clingo_id_t,
                                          value: *const ::std::os::raw::c_char)
                                          -> bool;
}
#[repr(u32)]
/// Enumeration for entries of the statistics.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_statistics_type {
    clingo_statistics_type_empty = 0,
    clingo_statistics_type_value = 1,
    clingo_statistics_type_array = 2,
    clingo_statistics_type_map = 3,
}
/// Corresponding type to ::clingo_statistics_type.
pub type clingo_statistics_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_statistic([u8; 0]);
/// Handle for to the solver statistics.
pub type clingo_statistics_t = clingo_statistic;
extern "C" {
    /// Get the root key of the statistics.
    ///
    /// **Parameters:**
    ///
    /// * `statistics` the target statistics
    /// * `key` the root key
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_statistics_root(statistics: *mut clingo_statistics_t, key: *mut u64) -> bool;
}
extern "C" {
    /// Get the type of a key.
    ///
    /// **Parameters:**
    ///
    /// * `statistics` the target statistics
    /// * `key` the key
    /// * `type` the resulting type
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_statistics_type(statistics: *mut clingo_statistics_t,
                                  key: u64,
                                  type_: *mut clingo_statistics_type_t)
                                  -> bool;
}
extern "C" {
    /// Get the size of an array entry.
    ///
    /// @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_array.
    ///
    /// **Parameters:**
    ///
    /// * `statistics` the target statistics
    /// * `key` the key
    /// * `size` the resulting size
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_statistics_array_size(statistics: *mut clingo_statistics_t,
                                        key: u64,
                                        size: *mut usize)
                                        -> bool;
}
extern "C" {
    /// Get the subkey at the given offset of an array entry.
    ///
    /// @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_array.
    ///
    /// **Parameters:**
    ///
    /// * `statistics` the target statistics
    /// * `key` the key
    /// * `offset` the offset in the array
    /// * `subkey` the resulting subkey
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_statistics_array_at(statistics: *mut clingo_statistics_t,
                                      key: u64,
                                      offset: usize,
                                      subkey: *mut u64)
                                      -> bool;
}
extern "C" {
    /// Get the number of subkeys of a map entry.
    ///
    /// @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_map.
    ///
    /// **Parameters:**
    ///
    /// * `statistics` the target statistics
    /// * `key` the key
    /// * `size` the resulting number
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_statistics_map_size(statistics: *mut clingo_statistics_t,
                                      key: u64,
                                      size: *mut usize)
                                      -> bool;
}
extern "C" {
    /// Get the name associated with the offset-th subkey.
    ///
    /// @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_map.
    ///
    /// **Parameters:**
    ///
    /// * `statistics` the target statistics
    /// * `key` the key
    /// * `offset` the offset of the name
    /// * `name` the resulting name
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_statistics_map_subkey_name(statistics: *mut clingo_statistics_t,
                                             key: u64,
                                             offset: usize,
                                             name: *mut *const ::std::os::raw::c_char)
                                             -> bool;
}
extern "C" {
    /// Lookup a subkey under the given name.
    ///
    /// @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_map.
    ///
    /// **Note:** Multiple levels can be looked up by concatenating keys with a period.
    ///
    /// **Parameters:**
    ///
    /// * `statistics` the target statistics
    /// * `key` the key
    /// * `name` the name to lookup the subkey
    /// * `subkey` the resulting subkey
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_statistics_map_at(statistics: *mut clingo_statistics_t,
                                    key: u64,
                                    name: *const ::std::os::raw::c_char,
                                    subkey: *mut u64)
                                    -> bool;
}
extern "C" {
    /// Get the value of the given entry.
    ///
    /// @pre The @link clingo_statistics_type() type@endlink of the entry must be @ref ::clingo_statistics_type_value.
    ///
    /// **Parameters:**
    ///
    /// * `statistics` the target statistics
    /// * `key` the key
    /// * `value` the resulting value
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_statistics_value_get(statistics: *mut clingo_statistics_t,
                                       key: u64,
                                       value: *mut f64)
                                       -> bool;
}
#[repr(u32)]
/// @addtogroup AST
/// @{
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_ast_comparison_operator {
    clingo_ast_comparison_operator_greater_than = 0,
    clingo_ast_comparison_operator_less_than = 1,
    clingo_ast_comparison_operator_less_equal = 2,
    clingo_ast_comparison_operator_greater_equal = 3,
    clingo_ast_comparison_operator_not_equal = 4,
    clingo_ast_comparison_operator_equal = 5,
}
pub type clingo_ast_comparison_operator_t = ::std::os::raw::c_int;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_ast_sign {
    clingo_ast_sign_none = 0,
    clingo_ast_sign_negation = 1,
    clingo_ast_sign_double_negation = 2,
}
pub type clingo_ast_sign_t = ::std::os::raw::c_int;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_ast_term_type {
    clingo_ast_term_type_symbol = 0,
    clingo_ast_term_type_variable = 1,
    clingo_ast_term_type_unary_operation = 2,
    clingo_ast_term_type_binary_operation = 3,
    clingo_ast_term_type_interval = 4,
    clingo_ast_term_type_function = 5,
    clingo_ast_term_type_external_function = 6,
    clingo_ast_term_type_pool = 7,
}
pub type clingo_ast_term_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_unary_operation {
    pub unary_operator: clingo_ast_unary_operator_t,
    pub argument: clingo_ast_term_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_unary_operation() {
    assert_eq!(::std::mem::size_of::<clingo_ast_unary_operation>(),
               72usize,
               concat!("Size of: ", stringify!(clingo_ast_unary_operation)));
    assert_eq!(::std::mem::align_of::<clingo_ast_unary_operation>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_unary_operation)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_unary_operation)).unary_operator as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_unary_operation),
                       "::",
                       stringify!(unary_operator)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_unary_operation)).argument as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_unary_operation),
                       "::",
                       stringify!(argument)));
}
impl Clone for clingo_ast_unary_operation {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_unary_operation_t = clingo_ast_unary_operation;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_binary_operation {
    pub binary_operator: clingo_ast_binary_operator_t,
    pub left: clingo_ast_term_t,
    pub right: clingo_ast_term_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_binary_operation() {
    assert_eq!(::std::mem::size_of::<clingo_ast_binary_operation>(),
               136usize,
               concat!("Size of: ", stringify!(clingo_ast_binary_operation)));
    assert_eq!(::std::mem::align_of::<clingo_ast_binary_operation>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_binary_operation)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_binary_operation))
                       .binary_operator as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_binary_operation),
                       "::",
                       stringify!(binary_operator)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_binary_operation)).left as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_binary_operation),
                       "::",
                       stringify!(left)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_binary_operation)).right as *const _ as usize },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_binary_operation),
                       "::",
                       stringify!(right)));
}
impl Clone for clingo_ast_binary_operation {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_binary_operation_t = clingo_ast_binary_operation;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_interval {
    pub left: clingo_ast_term_t,
    pub right: clingo_ast_term_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_interval() {
    assert_eq!(::std::mem::size_of::<clingo_ast_interval>(),
               128usize,
               concat!("Size of: ", stringify!(clingo_ast_interval)));
    assert_eq!(::std::mem::align_of::<clingo_ast_interval>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_interval)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_interval)).left as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_interval),
                       "::",
                       stringify!(left)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_interval)).right as *const _ as usize },
               64usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_interval),
                       "::",
                       stringify!(right)));
}
impl Clone for clingo_ast_interval {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_interval_t = clingo_ast_interval;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_function {
    pub name: *const ::std::os::raw::c_char,
    pub arguments: *mut clingo_ast_term_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_function() {
    assert_eq!(::std::mem::size_of::<clingo_ast_function>(),
               24usize,
               concat!("Size of: ", stringify!(clingo_ast_function)));
    assert_eq!(::std::mem::align_of::<clingo_ast_function>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_function)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_function)).name as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_function),
                       "::",
                       stringify!(name)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_function)).arguments as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_function),
                       "::",
                       stringify!(arguments)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_function)).size as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_function),
                       "::",
                       stringify!(size)));
}
impl Clone for clingo_ast_function {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_function_t = clingo_ast_function;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_pool {
    pub arguments: *mut clingo_ast_term_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_pool() {
    assert_eq!(::std::mem::size_of::<clingo_ast_pool>(),
               16usize,
               concat!("Size of: ", stringify!(clingo_ast_pool)));
    assert_eq!(::std::mem::align_of::<clingo_ast_pool>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_pool)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_pool)).arguments as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_pool),
                       "::",
                       stringify!(arguments)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_pool)).size as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_pool),
                       "::",
                       stringify!(size)));
}
impl Clone for clingo_ast_pool {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_pool_t = clingo_ast_pool;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_term {
    pub location: clingo_location_t,
    pub type_: clingo_ast_term_type_t,
    pub __bindgen_anon_1: clingo_ast_term__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_term__bindgen_ty_1 {
    pub symbol: __BindgenUnionField<clingo_symbol_t>,
    pub variable: __BindgenUnionField<*const ::std::os::raw::c_char>,
    pub unary_operation: __BindgenUnionField<*const clingo_ast_unary_operation_t>,
    pub binary_operation: __BindgenUnionField<*const clingo_ast_binary_operation_t>,
    pub interval: __BindgenUnionField<*const clingo_ast_interval_t>,
    pub function: __BindgenUnionField<*const clingo_ast_function_t>,
    pub external_function: __BindgenUnionField<*const clingo_ast_function_t>,
    pub pool: __BindgenUnionField<*const clingo_ast_pool_t>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_clingo_ast_term__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<clingo_ast_term__bindgen_ty_1>(),
               8usize,
               concat!("Size of: ", stringify!(clingo_ast_term__bindgen_ty_1)));
    assert_eq!(::std::mem::align_of::<clingo_ast_term__bindgen_ty_1>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_term__bindgen_ty_1)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_term__bindgen_ty_1)).symbol as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_term__bindgen_ty_1),
                       "::",
                       stringify!(symbol)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_term__bindgen_ty_1)).variable as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_term__bindgen_ty_1),
                       "::",
                       stringify!(variable)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_term__bindgen_ty_1))
                       .unary_operation as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_term__bindgen_ty_1),
                       "::",
                       stringify!(unary_operation)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_term__bindgen_ty_1))
                       .binary_operation as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_term__bindgen_ty_1),
                       "::",
                       stringify!(binary_operation)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_term__bindgen_ty_1)).interval as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_term__bindgen_ty_1),
                       "::",
                       stringify!(interval)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_term__bindgen_ty_1)).function as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_term__bindgen_ty_1),
                       "::",
                       stringify!(function)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_term__bindgen_ty_1))
                       .external_function as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_term__bindgen_ty_1),
                       "::",
                       stringify!(external_function)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_term__bindgen_ty_1)).pool as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_term__bindgen_ty_1),
                       "::",
                       stringify!(pool)));
}
impl Clone for clingo_ast_term__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_clingo_ast_term() {
    assert_eq!(::std::mem::size_of::<clingo_ast_term>(),
               64usize,
               concat!("Size of: ", stringify!(clingo_ast_term)));
    assert_eq!(::std::mem::align_of::<clingo_ast_term>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_term)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_term)).location as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_term),
                       "::",
                       stringify!(location)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_term)).type_ as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_term),
                       "::",
                       stringify!(type_)));
}
impl Clone for clingo_ast_term {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_term_t = clingo_ast_term;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_ast_unary_operator {
    clingo_ast_unary_operator_minus = 0,
    clingo_ast_unary_operator_negation = 1,
    clingo_ast_unary_operator_absolute = 2,
}
pub type clingo_ast_unary_operator_t = ::std::os::raw::c_int;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_ast_binary_operator {
    clingo_ast_binary_operator_xor = 0,
    clingo_ast_binary_operator_or = 1,
    clingo_ast_binary_operator_and = 2,
    clingo_ast_binary_operator_plus = 3,
    clingo_ast_binary_operator_minus = 4,
    clingo_ast_binary_operator_multiplication = 5,
    clingo_ast_binary_operator_division = 6,
    clingo_ast_binary_operator_modulo = 7,
}
pub type clingo_ast_binary_operator_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_csp_product_term {
    pub location: clingo_location_t,
    pub coefficient: clingo_ast_term_t,
    pub variable: *const clingo_ast_term_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_csp_product_term() {
    assert_eq!(::std::mem::size_of::<clingo_ast_csp_product_term>(),
               120usize,
               concat!("Size of: ", stringify!(clingo_ast_csp_product_term)));
    assert_eq!(::std::mem::align_of::<clingo_ast_csp_product_term>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_csp_product_term)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_csp_product_term)).location as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_csp_product_term),
                       "::",
                       stringify!(location)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_csp_product_term)).coefficient as *const _ as usize
               },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_csp_product_term),
                       "::",
                       stringify!(coefficient)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_csp_product_term)).variable as *const _ as usize
               },
               112usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_csp_product_term),
                       "::",
                       stringify!(variable)));
}
impl Clone for clingo_ast_csp_product_term {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_csp_product_term_t = clingo_ast_csp_product_term;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_csp_sum_term {
    pub location: clingo_location_t,
    pub terms: *mut clingo_ast_csp_product_term_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_csp_sum_term() {
    assert_eq!(::std::mem::size_of::<clingo_ast_csp_sum_term>(),
               64usize,
               concat!("Size of: ", stringify!(clingo_ast_csp_sum_term)));
    assert_eq!(::std::mem::align_of::<clingo_ast_csp_sum_term>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_csp_sum_term)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_csp_sum_term)).location as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_csp_sum_term),
                       "::",
                       stringify!(location)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_csp_sum_term)).terms as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_csp_sum_term),
                       "::",
                       stringify!(terms)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_csp_sum_term)).size as *const _ as usize },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_csp_sum_term),
                       "::",
                       stringify!(size)));
}
impl Clone for clingo_ast_csp_sum_term {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_csp_sum_term_t = clingo_ast_csp_sum_term;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_csp_guard {
    pub comparison: clingo_ast_comparison_operator_t,
    pub term: clingo_ast_csp_sum_term_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_csp_guard() {
    assert_eq!(::std::mem::size_of::<clingo_ast_csp_guard>(),
               72usize,
               concat!("Size of: ", stringify!(clingo_ast_csp_guard)));
    assert_eq!(::std::mem::align_of::<clingo_ast_csp_guard>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_csp_guard)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_csp_guard)).comparison as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_csp_guard),
                       "::",
                       stringify!(comparison)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_csp_guard)).term as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_csp_guard),
                       "::",
                       stringify!(term)));
}
impl Clone for clingo_ast_csp_guard {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_csp_guard_t = clingo_ast_csp_guard;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_csp_literal {
    pub term: clingo_ast_csp_sum_term_t,
    pub guards: *const clingo_ast_csp_guard_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_csp_literal() {
    assert_eq!(::std::mem::size_of::<clingo_ast_csp_literal>(),
               80usize,
               concat!("Size of: ", stringify!(clingo_ast_csp_literal)));
    assert_eq!(::std::mem::align_of::<clingo_ast_csp_literal>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_csp_literal)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_csp_literal)).term as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_csp_literal),
                       "::",
                       stringify!(term)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_csp_literal)).guards as *const _ as usize },
               64usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_csp_literal),
                       "::",
                       stringify!(guards)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_csp_literal)).size as *const _ as usize },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_csp_literal),
                       "::",
                       stringify!(size)));
}
impl Clone for clingo_ast_csp_literal {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_csp_literal_t = clingo_ast_csp_literal;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_id {
    pub location: clingo_location_t,
    pub id: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_clingo_ast_id() {
    assert_eq!(::std::mem::size_of::<clingo_ast_id>(),
               56usize,
               concat!("Size of: ", stringify!(clingo_ast_id)));
    assert_eq!(::std::mem::align_of::<clingo_ast_id>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_id)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_id)).location as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_id),
                       "::",
                       stringify!(location)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_id)).id as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_id),
                       "::",
                       stringify!(id)));
}
impl Clone for clingo_ast_id {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_id_t = clingo_ast_id;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_comparison {
    pub comparison: clingo_ast_comparison_operator_t,
    pub left: clingo_ast_term_t,
    pub right: clingo_ast_term_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_comparison() {
    assert_eq!(::std::mem::size_of::<clingo_ast_comparison>(),
               136usize,
               concat!("Size of: ", stringify!(clingo_ast_comparison)));
    assert_eq!(::std::mem::align_of::<clingo_ast_comparison>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_comparison)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_comparison)).comparison as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_comparison),
                       "::",
                       stringify!(comparison)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_comparison)).left as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_comparison),
                       "::",
                       stringify!(left)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_comparison)).right as *const _ as usize },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_comparison),
                       "::",
                       stringify!(right)));
}
impl Clone for clingo_ast_comparison {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_comparison_t = clingo_ast_comparison;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_ast_literal_type {
    clingo_ast_literal_type_boolean = 0,
    clingo_ast_literal_type_symbolic = 1,
    clingo_ast_literal_type_comparison = 2,
    clingo_ast_literal_type_csp = 3,
}
pub type clingo_ast_literal_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_literal {
    pub location: clingo_location_t,
    pub sign: clingo_ast_sign_t,
    pub type_: clingo_ast_literal_type_t,
    pub __bindgen_anon_1: clingo_ast_literal__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_literal__bindgen_ty_1 {
    pub boolean: __BindgenUnionField<bool>,
    pub symbol: __BindgenUnionField<*const clingo_ast_term_t>,
    pub comparison: __BindgenUnionField<*const clingo_ast_comparison_t>,
    pub csp_literal: __BindgenUnionField<*const clingo_ast_csp_literal_t>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_clingo_ast_literal__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<clingo_ast_literal__bindgen_ty_1>(),
               8usize,
               concat!("Size of: ", stringify!(clingo_ast_literal__bindgen_ty_1)));
    assert_eq!(::std::mem::align_of::<clingo_ast_literal__bindgen_ty_1>(),
               8usize,
               concat!("Alignment of ",
                       stringify!(clingo_ast_literal__bindgen_ty_1)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_literal__bindgen_ty_1)).boolean as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_literal__bindgen_ty_1),
                       "::",
                       stringify!(boolean)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_literal__bindgen_ty_1)).symbol as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_literal__bindgen_ty_1),
                       "::",
                       stringify!(symbol)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_literal__bindgen_ty_1))
                       .comparison as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_literal__bindgen_ty_1),
                       "::",
                       stringify!(comparison)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_literal__bindgen_ty_1))
                       .csp_literal as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_literal__bindgen_ty_1),
                       "::",
                       stringify!(csp_literal)));
}
impl Clone for clingo_ast_literal__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_clingo_ast_literal() {
    assert_eq!(::std::mem::size_of::<clingo_ast_literal>(),
               64usize,
               concat!("Size of: ", stringify!(clingo_ast_literal)));
    assert_eq!(::std::mem::align_of::<clingo_ast_literal>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_literal)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_literal)).location as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_literal),
                       "::",
                       stringify!(location)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_literal)).sign as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_literal),
                       "::",
                       stringify!(sign)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_literal)).type_ as *const _ as usize },
               52usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_literal),
                       "::",
                       stringify!(type_)));
}
impl Clone for clingo_ast_literal {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_literal_t = clingo_ast_literal;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_ast_aggregate_function {
    clingo_ast_aggregate_function_count = 0,
    clingo_ast_aggregate_function_sum = 1,
    clingo_ast_aggregate_function_sump = 2,
    clingo_ast_aggregate_function_min = 3,
    clingo_ast_aggregate_function_max = 4,
}
pub type clingo_ast_aggregate_function_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_aggregate_guard {
    pub comparison: clingo_ast_comparison_operator_t,
    pub term: clingo_ast_term_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_aggregate_guard() {
    assert_eq!(::std::mem::size_of::<clingo_ast_aggregate_guard>(),
               72usize,
               concat!("Size of: ", stringify!(clingo_ast_aggregate_guard)));
    assert_eq!(::std::mem::align_of::<clingo_ast_aggregate_guard>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_aggregate_guard)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_aggregate_guard)).comparison as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_aggregate_guard),
                       "::",
                       stringify!(comparison)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_aggregate_guard)).term as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_aggregate_guard),
                       "::",
                       stringify!(term)));
}
impl Clone for clingo_ast_aggregate_guard {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_aggregate_guard_t = clingo_ast_aggregate_guard;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_conditional_literal {
    pub literal: clingo_ast_literal_t,
    pub condition: *const clingo_ast_literal_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_conditional_literal() {
    assert_eq!(::std::mem::size_of::<clingo_ast_conditional_literal>(),
               80usize,
               concat!("Size of: ", stringify!(clingo_ast_conditional_literal)));
    assert_eq!(::std::mem::align_of::<clingo_ast_conditional_literal>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_conditional_literal)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_conditional_literal)).literal as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_conditional_literal),
                       "::",
                       stringify!(literal)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_conditional_literal)).condition as *const _ as usize
               },
               64usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_conditional_literal),
                       "::",
                       stringify!(condition)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_conditional_literal)).size as *const _ as usize
               },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_conditional_literal),
                       "::",
                       stringify!(size)));
}
impl Clone for clingo_ast_conditional_literal {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_conditional_literal_t = clingo_ast_conditional_literal;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_aggregate {
    pub elements: *const clingo_ast_conditional_literal_t,
    pub size: usize,
    pub left_guard: *const clingo_ast_aggregate_guard_t,
    pub right_guard: *const clingo_ast_aggregate_guard_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_aggregate() {
    assert_eq!(::std::mem::size_of::<clingo_ast_aggregate>(),
               32usize,
               concat!("Size of: ", stringify!(clingo_ast_aggregate)));
    assert_eq!(::std::mem::align_of::<clingo_ast_aggregate>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_aggregate)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_aggregate)).elements as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_aggregate),
                       "::",
                       stringify!(elements)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_aggregate)).size as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_aggregate),
                       "::",
                       stringify!(size)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_aggregate)).left_guard as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_aggregate),
                       "::",
                       stringify!(left_guard)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_aggregate)).right_guard as *const _ as usize },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_aggregate),
                       "::",
                       stringify!(right_guard)));
}
impl Clone for clingo_ast_aggregate {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_aggregate_t = clingo_ast_aggregate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_body_aggregate_element {
    pub tuple: *mut clingo_ast_term_t,
    pub tuple_size: usize,
    pub condition: *const clingo_ast_literal_t,
    pub condition_size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_body_aggregate_element() {
    assert_eq!(::std::mem::size_of::<clingo_ast_body_aggregate_element>(),
               32usize,
               concat!("Size of: ", stringify!(clingo_ast_body_aggregate_element)));
    assert_eq!(::std::mem::align_of::<clingo_ast_body_aggregate_element>(),
               8usize,
               concat!("Alignment of ",
                       stringify!(clingo_ast_body_aggregate_element)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_body_aggregate_element)).tuple as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_body_aggregate_element),
                       "::",
                       stringify!(tuple)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_body_aggregate_element))
                       .tuple_size as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_body_aggregate_element),
                       "::",
                       stringify!(tuple_size)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_body_aggregate_element))
                       .condition as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_body_aggregate_element),
                       "::",
                       stringify!(condition)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_body_aggregate_element))
                       .condition_size as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_body_aggregate_element),
                       "::",
                       stringify!(condition_size)));
}
impl Clone for clingo_ast_body_aggregate_element {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_body_aggregate_element_t = clingo_ast_body_aggregate_element;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_body_aggregate {
    pub function: clingo_ast_aggregate_function_t,
    pub elements: *const clingo_ast_body_aggregate_element_t,
    pub size: usize,
    pub left_guard: *const clingo_ast_aggregate_guard_t,
    pub right_guard: *const clingo_ast_aggregate_guard_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_body_aggregate() {
    assert_eq!(::std::mem::size_of::<clingo_ast_body_aggregate>(),
               40usize,
               concat!("Size of: ", stringify!(clingo_ast_body_aggregate)));
    assert_eq!(::std::mem::align_of::<clingo_ast_body_aggregate>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_body_aggregate)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_body_aggregate)).function as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_body_aggregate),
                       "::",
                       stringify!(function)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_body_aggregate)).elements as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_body_aggregate),
                       "::",
                       stringify!(elements)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_body_aggregate)).size as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_body_aggregate),
                       "::",
                       stringify!(size)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_body_aggregate)).left_guard as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_body_aggregate),
                       "::",
                       stringify!(left_guard)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_body_aggregate)).right_guard as *const _ as usize
               },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_body_aggregate),
                       "::",
                       stringify!(right_guard)));
}
impl Clone for clingo_ast_body_aggregate {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_body_aggregate_t = clingo_ast_body_aggregate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_head_aggregate_element {
    pub tuple: *const clingo_ast_term_t,
    pub tuple_size: usize,
    pub conditional_literal: clingo_ast_conditional_literal_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_head_aggregate_element() {
    assert_eq!(::std::mem::size_of::<clingo_ast_head_aggregate_element>(),
               96usize,
               concat!("Size of: ", stringify!(clingo_ast_head_aggregate_element)));
    assert_eq!(::std::mem::align_of::<clingo_ast_head_aggregate_element>(),
               8usize,
               concat!("Alignment of ",
                       stringify!(clingo_ast_head_aggregate_element)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_head_aggregate_element)).tuple as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_head_aggregate_element),
                       "::",
                       stringify!(tuple)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_head_aggregate_element))
                       .tuple_size as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_head_aggregate_element),
                       "::",
                       stringify!(tuple_size)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_head_aggregate_element))
                       .conditional_literal as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_head_aggregate_element),
                       "::",
                       stringify!(conditional_literal)));
}
impl Clone for clingo_ast_head_aggregate_element {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_head_aggregate_element_t = clingo_ast_head_aggregate_element;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_head_aggregate {
    pub function: clingo_ast_aggregate_function_t,
    pub elements: *const clingo_ast_head_aggregate_element_t,
    pub size: usize,
    pub left_guard: *const clingo_ast_aggregate_guard_t,
    pub right_guard: *const clingo_ast_aggregate_guard_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_head_aggregate() {
    assert_eq!(::std::mem::size_of::<clingo_ast_head_aggregate>(),
               40usize,
               concat!("Size of: ", stringify!(clingo_ast_head_aggregate)));
    assert_eq!(::std::mem::align_of::<clingo_ast_head_aggregate>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_head_aggregate)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_head_aggregate)).function as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_head_aggregate),
                       "::",
                       stringify!(function)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_head_aggregate)).elements as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_head_aggregate),
                       "::",
                       stringify!(elements)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_head_aggregate)).size as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_head_aggregate),
                       "::",
                       stringify!(size)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_head_aggregate)).left_guard as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_head_aggregate),
                       "::",
                       stringify!(left_guard)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_head_aggregate)).right_guard as *const _ as usize
               },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_head_aggregate),
                       "::",
                       stringify!(right_guard)));
}
impl Clone for clingo_ast_head_aggregate {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_head_aggregate_t = clingo_ast_head_aggregate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_disjunction {
    pub elements: *const clingo_ast_conditional_literal_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_disjunction() {
    assert_eq!(::std::mem::size_of::<clingo_ast_disjunction>(),
               16usize,
               concat!("Size of: ", stringify!(clingo_ast_disjunction)));
    assert_eq!(::std::mem::align_of::<clingo_ast_disjunction>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_disjunction)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_disjunction)).elements as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_disjunction),
                       "::",
                       stringify!(elements)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_disjunction)).size as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_disjunction),
                       "::",
                       stringify!(size)));
}
impl Clone for clingo_ast_disjunction {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_disjunction_t = clingo_ast_disjunction;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_disjoint_element {
    pub location: clingo_location_t,
    pub tuple: *const clingo_ast_term_t,
    pub tuple_size: usize,
    pub term: clingo_ast_csp_sum_term_t,
    pub condition: *const clingo_ast_literal_t,
    pub condition_size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_disjoint_element() {
    assert_eq!(::std::mem::size_of::<clingo_ast_disjoint_element>(),
               144usize,
               concat!("Size of: ", stringify!(clingo_ast_disjoint_element)));
    assert_eq!(::std::mem::align_of::<clingo_ast_disjoint_element>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_disjoint_element)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_disjoint_element)).location as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_disjoint_element),
                       "::",
                       stringify!(location)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_disjoint_element)).tuple as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_disjoint_element),
                       "::",
                       stringify!(tuple)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_disjoint_element)).tuple_size as *const _ as usize
               },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_disjoint_element),
                       "::",
                       stringify!(tuple_size)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_disjoint_element)).term as *const _ as usize },
               64usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_disjoint_element),
                       "::",
                       stringify!(term)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_disjoint_element)).condition as *const _ as usize
               },
               128usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_disjoint_element),
                       "::",
                       stringify!(condition)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_disjoint_element)).condition_size as *const _ as usize
               },
               136usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_disjoint_element),
                       "::",
                       stringify!(condition_size)));
}
impl Clone for clingo_ast_disjoint_element {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_disjoint_element_t = clingo_ast_disjoint_element;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_disjoint {
    pub elements: *const clingo_ast_disjoint_element_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_disjoint() {
    assert_eq!(::std::mem::size_of::<clingo_ast_disjoint>(),
               16usize,
               concat!("Size of: ", stringify!(clingo_ast_disjoint)));
    assert_eq!(::std::mem::align_of::<clingo_ast_disjoint>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_disjoint)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_disjoint)).elements as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_disjoint),
                       "::",
                       stringify!(elements)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_disjoint)).size as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_disjoint),
                       "::",
                       stringify!(size)));
}
impl Clone for clingo_ast_disjoint {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_disjoint_t = clingo_ast_disjoint;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_ast_theory_term_type {
    clingo_ast_theory_term_type_symbol = 0,
    clingo_ast_theory_term_type_variable = 1,
    clingo_ast_theory_term_type_tuple = 2,
    clingo_ast_theory_term_type_list = 3,
    clingo_ast_theory_term_type_set = 4,
    clingo_ast_theory_term_type_function = 5,
    clingo_ast_theory_term_type_unparsed_term = 6,
}
pub type clingo_ast_theory_term_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_theory_function {
    pub name: *const ::std::os::raw::c_char,
    pub arguments: *const clingo_ast_theory_term_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_function() {
    assert_eq!(::std::mem::size_of::<clingo_ast_theory_function>(),
               24usize,
               concat!("Size of: ", stringify!(clingo_ast_theory_function)));
    assert_eq!(::std::mem::align_of::<clingo_ast_theory_function>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_theory_function)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_theory_function)).name as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_function),
                       "::",
                       stringify!(name)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_function)).arguments as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_function),
                       "::",
                       stringify!(arguments)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_theory_function)).size as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_function),
                       "::",
                       stringify!(size)));
}
impl Clone for clingo_ast_theory_function {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_theory_function_t = clingo_ast_theory_function;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_theory_term_array {
    pub terms: *const clingo_ast_theory_term_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_term_array() {
    assert_eq!(::std::mem::size_of::<clingo_ast_theory_term_array>(),
               16usize,
               concat!("Size of: ", stringify!(clingo_ast_theory_term_array)));
    assert_eq!(::std::mem::align_of::<clingo_ast_theory_term_array>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_theory_term_array)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_term_array)).terms as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_term_array),
                       "::",
                       stringify!(terms)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_theory_term_array)).size as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_term_array),
                       "::",
                       stringify!(size)));
}
impl Clone for clingo_ast_theory_term_array {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_theory_term_array_t = clingo_ast_theory_term_array;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_theory_unparsed_term {
    pub elements: *const clingo_ast_theory_unparsed_term_element_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_unparsed_term() {
    assert_eq!(::std::mem::size_of::<clingo_ast_theory_unparsed_term>(),
               16usize,
               concat!("Size of: ", stringify!(clingo_ast_theory_unparsed_term)));
    assert_eq!(::std::mem::align_of::<clingo_ast_theory_unparsed_term>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_theory_unparsed_term)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_unparsed_term)).elements as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_unparsed_term),
                       "::",
                       stringify!(elements)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_unparsed_term)).size as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_unparsed_term),
                       "::",
                       stringify!(size)));
}
impl Clone for clingo_ast_theory_unparsed_term {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_theory_unparsed_term_t = clingo_ast_theory_unparsed_term;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_theory_term {
    pub location: clingo_location_t,
    pub type_: clingo_ast_theory_term_type_t,
    pub __bindgen_anon_1: clingo_ast_theory_term__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_theory_term__bindgen_ty_1 {
    pub symbol: __BindgenUnionField<clingo_symbol_t>,
    pub variable: __BindgenUnionField<*const ::std::os::raw::c_char>,
    pub tuple: __BindgenUnionField<*const clingo_ast_theory_term_array_t>,
    pub list: __BindgenUnionField<*const clingo_ast_theory_term_array_t>,
    pub set: __BindgenUnionField<*const clingo_ast_theory_term_array_t>,
    pub function: __BindgenUnionField<*const clingo_ast_theory_function_t>,
    pub unparsed_term: __BindgenUnionField<*const clingo_ast_theory_unparsed_term_t>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_term__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<clingo_ast_theory_term__bindgen_ty_1>(),
               8usize,
               concat!("Size of: ",
                       stringify!(clingo_ast_theory_term__bindgen_ty_1)));
    assert_eq!(::std::mem::align_of::<clingo_ast_theory_term__bindgen_ty_1>(),
               8usize,
               concat!("Alignment of ",
                       stringify!(clingo_ast_theory_term__bindgen_ty_1)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_term__bindgen_ty_1))
                       .symbol as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_term__bindgen_ty_1),
                       "::",
                       stringify!(symbol)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_term__bindgen_ty_1))
                       .variable as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_term__bindgen_ty_1),
                       "::",
                       stringify!(variable)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_term__bindgen_ty_1)).tuple as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_term__bindgen_ty_1),
                       "::",
                       stringify!(tuple)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_term__bindgen_ty_1)).list as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_term__bindgen_ty_1),
                       "::",
                       stringify!(list)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_term__bindgen_ty_1)).set as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_term__bindgen_ty_1),
                       "::",
                       stringify!(set)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_term__bindgen_ty_1))
                       .function as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_term__bindgen_ty_1),
                       "::",
                       stringify!(function)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_term__bindgen_ty_1))
                       .unparsed_term as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_term__bindgen_ty_1),
                       "::",
                       stringify!(unparsed_term)));
}
impl Clone for clingo_ast_theory_term__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_term() {
    assert_eq!(::std::mem::size_of::<clingo_ast_theory_term>(),
               64usize,
               concat!("Size of: ", stringify!(clingo_ast_theory_term)));
    assert_eq!(::std::mem::align_of::<clingo_ast_theory_term>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_theory_term)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_theory_term)).location as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_term),
                       "::",
                       stringify!(location)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_theory_term)).type_ as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_term),
                       "::",
                       stringify!(type_)));
}
impl Clone for clingo_ast_theory_term {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_theory_term_t = clingo_ast_theory_term;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_theory_unparsed_term_element {
    pub operators: *const *const ::std::os::raw::c_char,
    pub size: usize,
    pub term: clingo_ast_theory_term_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_unparsed_term_element() {
    assert_eq!(::std::mem::size_of::<clingo_ast_theory_unparsed_term_element>(),
               80usize,
               concat!("Size of: ",
                       stringify!(clingo_ast_theory_unparsed_term_element)));
    assert_eq!(::std::mem::align_of::<clingo_ast_theory_unparsed_term_element>(),
               8usize,
               concat!("Alignment of ",
                       stringify!(clingo_ast_theory_unparsed_term_element)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_unparsed_term_element))
                       .operators as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_unparsed_term_element),
                       "::",
                       stringify!(operators)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_unparsed_term_element))
                       .size as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_unparsed_term_element),
                       "::",
                       stringify!(size)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_unparsed_term_element))
                       .term as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_unparsed_term_element),
                       "::",
                       stringify!(term)));
}
impl Clone for clingo_ast_theory_unparsed_term_element {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_theory_unparsed_term_element_t = clingo_ast_theory_unparsed_term_element;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_theory_atom_element {
    pub tuple: *const clingo_ast_theory_term_t,
    pub tuple_size: usize,
    pub condition: *const clingo_ast_literal_t,
    pub condition_size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_atom_element() {
    assert_eq!(::std::mem::size_of::<clingo_ast_theory_atom_element>(),
               32usize,
               concat!("Size of: ", stringify!(clingo_ast_theory_atom_element)));
    assert_eq!(::std::mem::align_of::<clingo_ast_theory_atom_element>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_theory_atom_element)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_atom_element)).tuple as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_atom_element),
                       "::",
                       stringify!(tuple)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_atom_element)).tuple_size as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_atom_element),
                       "::",
                       stringify!(tuple_size)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_atom_element)).condition as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_atom_element),
                       "::",
                       stringify!(condition)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_atom_element))
                       .condition_size as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_atom_element),
                       "::",
                       stringify!(condition_size)));
}
impl Clone for clingo_ast_theory_atom_element {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_theory_atom_element_t = clingo_ast_theory_atom_element;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_theory_guard {
    pub operator_name: *const ::std::os::raw::c_char,
    pub term: clingo_ast_theory_term_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_guard() {
    assert_eq!(::std::mem::size_of::<clingo_ast_theory_guard>(),
               72usize,
               concat!("Size of: ", stringify!(clingo_ast_theory_guard)));
    assert_eq!(::std::mem::align_of::<clingo_ast_theory_guard>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_theory_guard)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_guard)).operator_name as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_guard),
                       "::",
                       stringify!(operator_name)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_theory_guard)).term as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_guard),
                       "::",
                       stringify!(term)));
}
impl Clone for clingo_ast_theory_guard {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_theory_guard_t = clingo_ast_theory_guard;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_theory_atom {
    pub term: clingo_ast_term_t,
    pub elements: *const clingo_ast_theory_atom_element_t,
    pub size: usize,
    pub guard: *const clingo_ast_theory_guard_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_atom() {
    assert_eq!(::std::mem::size_of::<clingo_ast_theory_atom>(),
               88usize,
               concat!("Size of: ", stringify!(clingo_ast_theory_atom)));
    assert_eq!(::std::mem::align_of::<clingo_ast_theory_atom>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_theory_atom)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_theory_atom)).term as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_atom),
                       "::",
                       stringify!(term)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_theory_atom)).elements as *const _ as usize },
               64usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_atom),
                       "::",
                       stringify!(elements)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_theory_atom)).size as *const _ as usize },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_atom),
                       "::",
                       stringify!(size)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_theory_atom)).guard as *const _ as usize },
               80usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_atom),
                       "::",
                       stringify!(guard)));
}
impl Clone for clingo_ast_theory_atom {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_theory_atom_t = clingo_ast_theory_atom;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_ast_head_literal_type {
    clingo_ast_head_literal_type_literal = 0,
    clingo_ast_head_literal_type_disjunction = 1,
    clingo_ast_head_literal_type_aggregate = 2,
    clingo_ast_head_literal_type_head_aggregate = 3,
    clingo_ast_head_literal_type_theory_atom = 4,
}
pub type clingo_ast_head_literal_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_head_literal {
    pub location: clingo_location_t,
    pub type_: clingo_ast_head_literal_type_t,
    pub __bindgen_anon_1: clingo_ast_head_literal__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_head_literal__bindgen_ty_1 {
    pub literal: __BindgenUnionField<*const clingo_ast_literal_t>,
    pub disjunction: __BindgenUnionField<*const clingo_ast_disjunction_t>,
    pub aggregate: __BindgenUnionField<*const clingo_ast_aggregate_t>,
    pub head_aggregate: __BindgenUnionField<*const clingo_ast_head_aggregate_t>,
    pub theory_atom: __BindgenUnionField<*const clingo_ast_theory_atom_t>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_clingo_ast_head_literal__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<clingo_ast_head_literal__bindgen_ty_1>(),
               8usize,
               concat!("Size of: ",
                       stringify!(clingo_ast_head_literal__bindgen_ty_1)));
    assert_eq!(::std::mem::align_of::<clingo_ast_head_literal__bindgen_ty_1>(),
               8usize,
               concat!("Alignment of ",
                       stringify!(clingo_ast_head_literal__bindgen_ty_1)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_head_literal__bindgen_ty_1))
                       .literal as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_head_literal__bindgen_ty_1),
                       "::",
                       stringify!(literal)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_head_literal__bindgen_ty_1))
                       .disjunction as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_head_literal__bindgen_ty_1),
                       "::",
                       stringify!(disjunction)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_head_literal__bindgen_ty_1))
                       .aggregate as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_head_literal__bindgen_ty_1),
                       "::",
                       stringify!(aggregate)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_head_literal__bindgen_ty_1))
                       .head_aggregate as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_head_literal__bindgen_ty_1),
                       "::",
                       stringify!(head_aggregate)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_head_literal__bindgen_ty_1))
                       .theory_atom as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_head_literal__bindgen_ty_1),
                       "::",
                       stringify!(theory_atom)));
}
impl Clone for clingo_ast_head_literal__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_clingo_ast_head_literal() {
    assert_eq!(::std::mem::size_of::<clingo_ast_head_literal>(),
               64usize,
               concat!("Size of: ", stringify!(clingo_ast_head_literal)));
    assert_eq!(::std::mem::align_of::<clingo_ast_head_literal>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_head_literal)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_head_literal)).location as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_head_literal),
                       "::",
                       stringify!(location)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_head_literal)).type_ as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_head_literal),
                       "::",
                       stringify!(type_)));
}
impl Clone for clingo_ast_head_literal {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_head_literal_t = clingo_ast_head_literal;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_ast_body_literal_type {
    clingo_ast_body_literal_type_literal = 0,
    clingo_ast_body_literal_type_conditional = 1,
    clingo_ast_body_literal_type_aggregate = 2,
    clingo_ast_body_literal_type_body_aggregate = 3,
    clingo_ast_body_literal_type_theory_atom = 4,
    clingo_ast_body_literal_type_disjoint = 5,
}
pub type clingo_ast_body_literal_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_body_literal {
    pub location: clingo_location_t,
    pub sign: clingo_ast_sign_t,
    pub type_: clingo_ast_body_literal_type_t,
    pub __bindgen_anon_1: clingo_ast_body_literal__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_body_literal__bindgen_ty_1 {
    pub literal: __BindgenUnionField<*const clingo_ast_literal_t>,
    pub conditional: __BindgenUnionField<*const clingo_ast_conditional_literal_t>,
    pub aggregate: __BindgenUnionField<*const clingo_ast_aggregate_t>,
    pub body_aggregate: __BindgenUnionField<*const clingo_ast_body_aggregate_t>,
    pub theory_atom: __BindgenUnionField<*const clingo_ast_theory_atom_t>,
    pub disjoint: __BindgenUnionField<*const clingo_ast_disjoint_t>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_clingo_ast_body_literal__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<clingo_ast_body_literal__bindgen_ty_1>(),
               8usize,
               concat!("Size of: ",
                       stringify!(clingo_ast_body_literal__bindgen_ty_1)));
    assert_eq!(::std::mem::align_of::<clingo_ast_body_literal__bindgen_ty_1>(),
               8usize,
               concat!("Alignment of ",
                       stringify!(clingo_ast_body_literal__bindgen_ty_1)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_body_literal__bindgen_ty_1))
                       .literal as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_body_literal__bindgen_ty_1),
                       "::",
                       stringify!(literal)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_body_literal__bindgen_ty_1))
                       .conditional as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_body_literal__bindgen_ty_1),
                       "::",
                       stringify!(conditional)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_body_literal__bindgen_ty_1))
                       .aggregate as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_body_literal__bindgen_ty_1),
                       "::",
                       stringify!(aggregate)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_body_literal__bindgen_ty_1))
                       .body_aggregate as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_body_literal__bindgen_ty_1),
                       "::",
                       stringify!(body_aggregate)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_body_literal__bindgen_ty_1))
                       .theory_atom as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_body_literal__bindgen_ty_1),
                       "::",
                       stringify!(theory_atom)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_body_literal__bindgen_ty_1))
                       .disjoint as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_body_literal__bindgen_ty_1),
                       "::",
                       stringify!(disjoint)));
}
impl Clone for clingo_ast_body_literal__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_clingo_ast_body_literal() {
    assert_eq!(::std::mem::size_of::<clingo_ast_body_literal>(),
               64usize,
               concat!("Size of: ", stringify!(clingo_ast_body_literal)));
    assert_eq!(::std::mem::align_of::<clingo_ast_body_literal>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_body_literal)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_body_literal)).location as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_body_literal),
                       "::",
                       stringify!(location)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_body_literal)).sign as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_body_literal),
                       "::",
                       stringify!(sign)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_body_literal)).type_ as *const _ as usize },
               52usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_body_literal),
                       "::",
                       stringify!(type_)));
}
impl Clone for clingo_ast_body_literal {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_body_literal_t = clingo_ast_body_literal;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_ast_theory_operator_type {
    clingo_ast_theory_operator_type_unary = 0,
    clingo_ast_theory_operator_type_binary_left = 1,
    clingo_ast_theory_operator_type_binary_right = 2,
}
pub type clingo_ast_theory_operator_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_theory_operator_definition {
    pub location: clingo_location_t,
    pub name: *const ::std::os::raw::c_char,
    pub priority: ::std::os::raw::c_uint,
    pub type_: clingo_ast_theory_operator_type_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_operator_definition() {
    assert_eq!(::std::mem::size_of::<clingo_ast_theory_operator_definition>(),
               64usize,
               concat!("Size of: ",
                       stringify!(clingo_ast_theory_operator_definition)));
    assert_eq!(::std::mem::align_of::<clingo_ast_theory_operator_definition>(),
               8usize,
               concat!("Alignment of ",
                       stringify!(clingo_ast_theory_operator_definition)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_operator_definition))
                       .location as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_operator_definition),
                       "::",
                       stringify!(location)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_operator_definition)).name as *const _ as usize
               },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_operator_definition),
                       "::",
                       stringify!(name)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_operator_definition))
                       .priority as *const _ as usize
               },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_operator_definition),
                       "::",
                       stringify!(priority)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_operator_definition))
                       .type_ as *const _ as usize
               },
               60usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_operator_definition),
                       "::",
                       stringify!(type_)));
}
impl Clone for clingo_ast_theory_operator_definition {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_theory_operator_definition_t = clingo_ast_theory_operator_definition;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_theory_term_definition {
    pub location: clingo_location_t,
    pub name: *const ::std::os::raw::c_char,
    pub operators: *const clingo_ast_theory_operator_definition_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_term_definition() {
    assert_eq!(::std::mem::size_of::<clingo_ast_theory_term_definition>(),
               72usize,
               concat!("Size of: ", stringify!(clingo_ast_theory_term_definition)));
    assert_eq!(::std::mem::align_of::<clingo_ast_theory_term_definition>(),
               8usize,
               concat!("Alignment of ",
                       stringify!(clingo_ast_theory_term_definition)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_term_definition)).location as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_term_definition),
                       "::",
                       stringify!(location)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_term_definition)).name as *const _ as usize
               },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_term_definition),
                       "::",
                       stringify!(name)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_term_definition))
                       .operators as *const _ as usize
               },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_term_definition),
                       "::",
                       stringify!(operators)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_term_definition)).size as *const _ as usize
               },
               64usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_term_definition),
                       "::",
                       stringify!(size)));
}
impl Clone for clingo_ast_theory_term_definition {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_theory_term_definition_t = clingo_ast_theory_term_definition;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_theory_guard_definition {
    pub term: *const ::std::os::raw::c_char,
    pub operators: *const *const ::std::os::raw::c_char,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_guard_definition() {
    assert_eq!(::std::mem::size_of::<clingo_ast_theory_guard_definition>(),
               24usize,
               concat!("Size of: ", stringify!(clingo_ast_theory_guard_definition)));
    assert_eq!(::std::mem::align_of::<clingo_ast_theory_guard_definition>(),
               8usize,
               concat!("Alignment of ",
                       stringify!(clingo_ast_theory_guard_definition)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_guard_definition)).term as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_guard_definition),
                       "::",
                       stringify!(term)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_guard_definition))
                       .operators as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_guard_definition),
                       "::",
                       stringify!(operators)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_guard_definition)).size as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_guard_definition),
                       "::",
                       stringify!(size)));
}
impl Clone for clingo_ast_theory_guard_definition {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_theory_guard_definition_t = clingo_ast_theory_guard_definition;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_ast_theory_atom_definition_type {
    clingo_ast_theory_atom_definition_type_head = 0,
    clingo_ast_theory_atom_definition_type_body = 1,
    clingo_ast_theory_atom_definition_type_any = 2,
    clingo_ast_theory_atom_definition_type_directive = 3,
}
pub type clingo_ast_theory_atom_definition_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_theory_atom_definition {
    pub location: clingo_location_t,
    pub type_: clingo_ast_theory_atom_definition_type_t,
    pub name: *const ::std::os::raw::c_char,
    pub arity: ::std::os::raw::c_uint,
    pub elements: *const ::std::os::raw::c_char,
    pub guard: *const clingo_ast_theory_guard_definition_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_atom_definition() {
    assert_eq!(::std::mem::size_of::<clingo_ast_theory_atom_definition>(),
               88usize,
               concat!("Size of: ", stringify!(clingo_ast_theory_atom_definition)));
    assert_eq!(::std::mem::align_of::<clingo_ast_theory_atom_definition>(),
               8usize,
               concat!("Alignment of ",
                       stringify!(clingo_ast_theory_atom_definition)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_atom_definition)).location as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_atom_definition),
                       "::",
                       stringify!(location)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_atom_definition)).type_ as *const _ as usize
               },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_atom_definition),
                       "::",
                       stringify!(type_)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_atom_definition)).name as *const _ as usize
               },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_atom_definition),
                       "::",
                       stringify!(name)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_atom_definition)).arity as *const _ as usize
               },
               64usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_atom_definition),
                       "::",
                       stringify!(arity)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_atom_definition)).elements as *const _ as usize
               },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_atom_definition),
                       "::",
                       stringify!(elements)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_atom_definition)).guard as *const _ as usize
               },
               80usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_atom_definition),
                       "::",
                       stringify!(guard)));
}
impl Clone for clingo_ast_theory_atom_definition {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_theory_atom_definition_t = clingo_ast_theory_atom_definition;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_theory_definition {
    pub name: *const ::std::os::raw::c_char,
    pub terms: *const clingo_ast_theory_term_definition_t,
    pub terms_size: usize,
    pub atoms: *const clingo_ast_theory_atom_definition_t,
    pub atoms_size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_theory_definition() {
    assert_eq!(::std::mem::size_of::<clingo_ast_theory_definition>(),
               40usize,
               concat!("Size of: ", stringify!(clingo_ast_theory_definition)));
    assert_eq!(::std::mem::align_of::<clingo_ast_theory_definition>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_theory_definition)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_theory_definition)).name as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_definition),
                       "::",
                       stringify!(name)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_definition)).terms as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_definition),
                       "::",
                       stringify!(terms)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_definition)).terms_size as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_definition),
                       "::",
                       stringify!(terms_size)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_definition)).atoms as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_definition),
                       "::",
                       stringify!(atoms)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_theory_definition)).atoms_size as *const _ as usize
               },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_theory_definition),
                       "::",
                       stringify!(atoms_size)));
}
impl Clone for clingo_ast_theory_definition {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_theory_definition_t = clingo_ast_theory_definition;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_rule {
    pub head: clingo_ast_head_literal_t,
    pub body: *const clingo_ast_body_literal_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_rule() {
    assert_eq!(::std::mem::size_of::<clingo_ast_rule>(),
               80usize,
               concat!("Size of: ", stringify!(clingo_ast_rule)));
    assert_eq!(::std::mem::align_of::<clingo_ast_rule>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_rule)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_rule)).head as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_rule),
                       "::",
                       stringify!(head)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_rule)).body as *const _ as usize },
               64usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_rule),
                       "::",
                       stringify!(body)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_rule)).size as *const _ as usize },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_rule),
                       "::",
                       stringify!(size)));
}
impl Clone for clingo_ast_rule {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_rule_t = clingo_ast_rule;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_definition {
    pub name: *const ::std::os::raw::c_char,
    pub value: clingo_ast_term_t,
    pub is_default: bool,
}
#[test]
fn bindgen_test_layout_clingo_ast_definition() {
    assert_eq!(::std::mem::size_of::<clingo_ast_definition>(),
               80usize,
               concat!("Size of: ", stringify!(clingo_ast_definition)));
    assert_eq!(::std::mem::align_of::<clingo_ast_definition>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_definition)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_definition)).name as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_definition),
                       "::",
                       stringify!(name)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_definition)).value as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_definition),
                       "::",
                       stringify!(value)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_definition)).is_default as *const _ as usize },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_definition),
                       "::",
                       stringify!(is_default)));
}
impl Clone for clingo_ast_definition {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_definition_t = clingo_ast_definition;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_show_signature {
    pub signature: clingo_signature_t,
    pub csp: bool,
}
#[test]
fn bindgen_test_layout_clingo_ast_show_signature() {
    assert_eq!(::std::mem::size_of::<clingo_ast_show_signature>(),
               16usize,
               concat!("Size of: ", stringify!(clingo_ast_show_signature)));
    assert_eq!(::std::mem::align_of::<clingo_ast_show_signature>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_show_signature)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_show_signature)).signature as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_show_signature),
                       "::",
                       stringify!(signature)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_show_signature)).csp as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_show_signature),
                       "::",
                       stringify!(csp)));
}
impl Clone for clingo_ast_show_signature {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_show_signature_t = clingo_ast_show_signature;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_show_term {
    pub term: clingo_ast_term_t,
    pub body: *const clingo_ast_body_literal_t,
    pub size: usize,
    pub csp: bool,
}
#[test]
fn bindgen_test_layout_clingo_ast_show_term() {
    assert_eq!(::std::mem::size_of::<clingo_ast_show_term>(),
               88usize,
               concat!("Size of: ", stringify!(clingo_ast_show_term)));
    assert_eq!(::std::mem::align_of::<clingo_ast_show_term>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_show_term)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_show_term)).term as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_show_term),
                       "::",
                       stringify!(term)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_show_term)).body as *const _ as usize },
               64usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_show_term),
                       "::",
                       stringify!(body)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_show_term)).size as *const _ as usize },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_show_term),
                       "::",
                       stringify!(size)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_show_term)).csp as *const _ as usize },
               80usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_show_term),
                       "::",
                       stringify!(csp)));
}
impl Clone for clingo_ast_show_term {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_show_term_t = clingo_ast_show_term;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_minimize {
    pub weight: clingo_ast_term_t,
    pub priority: clingo_ast_term_t,
    pub tuple: *const clingo_ast_term_t,
    pub tuple_size: usize,
    pub body: *const clingo_ast_body_literal_t,
    pub body_size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_minimize() {
    assert_eq!(::std::mem::size_of::<clingo_ast_minimize>(),
               160usize,
               concat!("Size of: ", stringify!(clingo_ast_minimize)));
    assert_eq!(::std::mem::align_of::<clingo_ast_minimize>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_minimize)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_minimize)).weight as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_minimize),
                       "::",
                       stringify!(weight)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_minimize)).priority as *const _ as usize },
               64usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_minimize),
                       "::",
                       stringify!(priority)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_minimize)).tuple as *const _ as usize },
               128usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_minimize),
                       "::",
                       stringify!(tuple)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_minimize)).tuple_size as *const _ as usize },
               136usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_minimize),
                       "::",
                       stringify!(tuple_size)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_minimize)).body as *const _ as usize },
               144usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_minimize),
                       "::",
                       stringify!(body)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_minimize)).body_size as *const _ as usize },
               152usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_minimize),
                       "::",
                       stringify!(body_size)));
}
impl Clone for clingo_ast_minimize {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_minimize_t = clingo_ast_minimize;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_ast_script_type {
    clingo_ast_script_type_lua = 0,
    clingo_ast_script_type_python = 1,
}
pub type clingo_ast_script_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_script {
    pub type_: clingo_ast_script_type_t,
    pub code: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_clingo_ast_script() {
    assert_eq!(::std::mem::size_of::<clingo_ast_script>(),
               16usize,
               concat!("Size of: ", stringify!(clingo_ast_script)));
    assert_eq!(::std::mem::align_of::<clingo_ast_script>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_script)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_script)).type_ as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_script),
                       "::",
                       stringify!(type_)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_script)).code as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_script),
                       "::",
                       stringify!(code)));
}
impl Clone for clingo_ast_script {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_script_t = clingo_ast_script;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_program {
    pub name: *const ::std::os::raw::c_char,
    pub parameters: *const clingo_ast_id_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_program() {
    assert_eq!(::std::mem::size_of::<clingo_ast_program>(),
               24usize,
               concat!("Size of: ", stringify!(clingo_ast_program)));
    assert_eq!(::std::mem::align_of::<clingo_ast_program>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_program)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_program)).name as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_program),
                       "::",
                       stringify!(name)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_program)).parameters as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_program),
                       "::",
                       stringify!(parameters)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_program)).size as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_program),
                       "::",
                       stringify!(size)));
}
impl Clone for clingo_ast_program {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_program_t = clingo_ast_program;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_external {
    pub atom: clingo_ast_term_t,
    pub body: *const clingo_ast_body_literal_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_external() {
    assert_eq!(::std::mem::size_of::<clingo_ast_external>(),
               80usize,
               concat!("Size of: ", stringify!(clingo_ast_external)));
    assert_eq!(::std::mem::align_of::<clingo_ast_external>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_external)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_external)).atom as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_external),
                       "::",
                       stringify!(atom)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_external)).body as *const _ as usize },
               64usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_external),
                       "::",
                       stringify!(body)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_external)).size as *const _ as usize },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_external),
                       "::",
                       stringify!(size)));
}
impl Clone for clingo_ast_external {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_external_t = clingo_ast_external;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_edge {
    pub u: clingo_ast_term_t,
    pub v: clingo_ast_term_t,
    pub body: *const clingo_ast_body_literal_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_edge() {
    assert_eq!(::std::mem::size_of::<clingo_ast_edge>(),
               144usize,
               concat!("Size of: ", stringify!(clingo_ast_edge)));
    assert_eq!(::std::mem::align_of::<clingo_ast_edge>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_edge)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_edge)).u as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_edge),
                       "::",
                       stringify!(u)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_edge)).v as *const _ as usize },
               64usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_edge),
                       "::",
                       stringify!(v)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_edge)).body as *const _ as usize },
               128usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_edge),
                       "::",
                       stringify!(body)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_edge)).size as *const _ as usize },
               136usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_edge),
                       "::",
                       stringify!(size)));
}
impl Clone for clingo_ast_edge {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_edge_t = clingo_ast_edge;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_heuristic {
    pub atom: clingo_ast_term_t,
    pub body: *const clingo_ast_body_literal_t,
    pub size: usize,
    pub bias: clingo_ast_term_t,
    pub priority: clingo_ast_term_t,
    pub modifier: clingo_ast_term_t,
}
#[test]
fn bindgen_test_layout_clingo_ast_heuristic() {
    assert_eq!(::std::mem::size_of::<clingo_ast_heuristic>(),
               272usize,
               concat!("Size of: ", stringify!(clingo_ast_heuristic)));
    assert_eq!(::std::mem::align_of::<clingo_ast_heuristic>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_heuristic)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_heuristic)).atom as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_heuristic),
                       "::",
                       stringify!(atom)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_heuristic)).body as *const _ as usize },
               64usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_heuristic),
                       "::",
                       stringify!(body)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_heuristic)).size as *const _ as usize },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_heuristic),
                       "::",
                       stringify!(size)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_heuristic)).bias as *const _ as usize },
               80usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_heuristic),
                       "::",
                       stringify!(bias)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_heuristic)).priority as *const _ as usize },
               144usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_heuristic),
                       "::",
                       stringify!(priority)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_heuristic)).modifier as *const _ as usize },
               208usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_heuristic),
                       "::",
                       stringify!(modifier)));
}
impl Clone for clingo_ast_heuristic {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_heuristic_t = clingo_ast_heuristic;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_project {
    pub atom: clingo_ast_term_t,
    pub body: *const clingo_ast_body_literal_t,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_ast_project() {
    assert_eq!(::std::mem::size_of::<clingo_ast_project>(),
               80usize,
               concat!("Size of: ", stringify!(clingo_ast_project)));
    assert_eq!(::std::mem::align_of::<clingo_ast_project>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_project)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_project)).atom as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_project),
                       "::",
                       stringify!(atom)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_project)).body as *const _ as usize },
               64usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_project),
                       "::",
                       stringify!(body)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_project)).size as *const _ as usize },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_project),
                       "::",
                       stringify!(size)));
}
impl Clone for clingo_ast_project {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_project_t = clingo_ast_project;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clingo_ast_statement_type {
    clingo_ast_statement_type_rule = 0,
    clingo_ast_statement_type_const = 1,
    clingo_ast_statement_type_show_signature = 2,
    clingo_ast_statement_type_show_term = 3,
    clingo_ast_statement_type_minimize = 4,
    clingo_ast_statement_type_script = 5,
    clingo_ast_statement_type_program = 6,
    clingo_ast_statement_type_external = 7,
    clingo_ast_statement_type_edge = 8,
    clingo_ast_statement_type_heuristic = 9,
    clingo_ast_statement_type_project_atom = 10,
    clingo_ast_statement_type_project_atom_signature = 11,
    clingo_ast_statement_type_theory_definition = 12,
}
pub type clingo_ast_statement_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_statement {
    pub location: clingo_location_t,
    pub type_: clingo_ast_statement_type_t,
    pub __bindgen_anon_1: clingo_ast_statement__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ast_statement__bindgen_ty_1 {
    pub rule: __BindgenUnionField<*const clingo_ast_rule_t>,
    pub definition: __BindgenUnionField<*const clingo_ast_definition_t>,
    pub show_signature: __BindgenUnionField<*const clingo_ast_show_signature_t>,
    pub show_term: __BindgenUnionField<*const clingo_ast_show_term_t>,
    pub minimize: __BindgenUnionField<*const clingo_ast_minimize_t>,
    pub script: __BindgenUnionField<*const clingo_ast_script_t>,
    pub program: __BindgenUnionField<*const clingo_ast_program_t>,
    pub external: __BindgenUnionField<*const clingo_ast_external_t>,
    pub edge: __BindgenUnionField<*const clingo_ast_edge_t>,
    pub heuristic: __BindgenUnionField<*const clingo_ast_heuristic_t>,
    pub project_atom: __BindgenUnionField<*const clingo_ast_project_t>,
    pub project_signature: __BindgenUnionField<clingo_signature_t>,
    pub theory_definition: __BindgenUnionField<*const clingo_ast_theory_definition_t>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_clingo_ast_statement__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<clingo_ast_statement__bindgen_ty_1>(),
               8usize,
               concat!("Size of: ", stringify!(clingo_ast_statement__bindgen_ty_1)));
    assert_eq!(::std::mem::align_of::<clingo_ast_statement__bindgen_ty_1>(),
               8usize,
               concat!("Alignment of ",
                       stringify!(clingo_ast_statement__bindgen_ty_1)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_statement__bindgen_ty_1)).rule as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_statement__bindgen_ty_1),
                       "::",
                       stringify!(rule)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_statement__bindgen_ty_1))
                       .definition as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_statement__bindgen_ty_1),
                       "::",
                       stringify!(definition)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_statement__bindgen_ty_1))
                       .show_signature as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_statement__bindgen_ty_1),
                       "::",
                       stringify!(show_signature)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_statement__bindgen_ty_1))
                       .show_term as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_statement__bindgen_ty_1),
                       "::",
                       stringify!(show_term)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_statement__bindgen_ty_1))
                       .minimize as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_statement__bindgen_ty_1),
                       "::",
                       stringify!(minimize)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_statement__bindgen_ty_1)).script as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_statement__bindgen_ty_1),
                       "::",
                       stringify!(script)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_statement__bindgen_ty_1)).program as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_statement__bindgen_ty_1),
                       "::",
                       stringify!(program)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_statement__bindgen_ty_1))
                       .external as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_statement__bindgen_ty_1),
                       "::",
                       stringify!(external)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_statement__bindgen_ty_1)).edge as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_statement__bindgen_ty_1),
                       "::",
                       stringify!(edge)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_statement__bindgen_ty_1))
                       .heuristic as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_statement__bindgen_ty_1),
                       "::",
                       stringify!(heuristic)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_statement__bindgen_ty_1))
                       .project_atom as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_statement__bindgen_ty_1),
                       "::",
                       stringify!(project_atom)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_statement__bindgen_ty_1))
                       .project_signature as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_statement__bindgen_ty_1),
                       "::",
                       stringify!(project_signature)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ast_statement__bindgen_ty_1))
                       .theory_definition as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_statement__bindgen_ty_1),
                       "::",
                       stringify!(theory_definition)));
}
impl Clone for clingo_ast_statement__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_clingo_ast_statement() {
    assert_eq!(::std::mem::size_of::<clingo_ast_statement>(),
               64usize,
               concat!("Size of: ", stringify!(clingo_ast_statement)));
    assert_eq!(::std::mem::align_of::<clingo_ast_statement>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ast_statement)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_statement)).location as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_statement),
                       "::",
                       stringify!(location)));
    assert_eq!(unsafe { &(*(0 as *const clingo_ast_statement)).type_ as *const _ as usize },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ast_statement),
                       "::",
                       stringify!(type_)));
}
impl Clone for clingo_ast_statement {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ast_statement_t = clingo_ast_statement;
pub type clingo_ast_callback_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const clingo_ast_statement_t,
                                                 arg2: *mut ::std::os::raw::c_void)
                                                 -> bool>;
extern "C" {
    /// Parse the given program and return an abstract syntax tree for each statement via a callback.
    ///
    /// **Parameters:**
    ///
    /// * `program` the program in gringo syntax
    /// * `callback` the callback reporting statements
    /// * `callback_data` user data for the callback
    /// * `logger` callback to report messages during parsing
    /// * `logger_data` user data for the logger
    /// * `message_limit` the maximum number of times the logger is called
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_runtime if parsing fails
    /// - ::clingo_error_bad_alloc
    pub fn clingo_parse_program(program: *const ::std::os::raw::c_char,
                                callback: clingo_ast_callback_t,
                                callback_data: *mut ::std::os::raw::c_void,
                                logger: clingo_logger_t,
                                logger_data: *mut ::std::os::raw::c_void,
                                message_limit: ::std::os::raw::c_uint)
                                -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_program_builder([u8; 0]);
/// Object to build non-ground programs.
pub type clingo_program_builder_t = clingo_program_builder;
extern "C" {
    /// Begin building a program.
    ///
    /// * `builder` - the target program builder
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_program_builder_begin(builder: *mut clingo_program_builder_t) -> bool;
}
extern "C" {
    /// Adds a statement to the program.
    ///
    /// @attention @ref clingo_program_builder_begin() must be called before adding statements and @ref clingo_program_builder_end() must be called after all statements have been added.
    ///
    /// **Parameters:**
    ///
    /// * `builder` - the target program builder
    /// * `statement` - the statement to add
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_runtime for statements of invalid form
    /// - ::clingo_error_bad_alloc
    pub fn clingo_program_builder_add(builder: *mut clingo_program_builder_t,
                                      statement: *const clingo_ast_statement_t)
                                      -> bool;
}
extern "C" {
    /// End building a program.
    ///
    /// * `builder` - the target program builder
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_program_builder_end(builder: *mut clingo_program_builder_t) -> bool;
}
/// An instance of this struct has to be registered with a solver to observe ground directives as they are passed to the solver.
///
///
/// **Note:** This interface is closely modeled after the aspif format.
/// For more information please refer to the specification of the aspif format.
///
/// Not all callbacks have to be implemented and can be set to NULL if not needed.
/// If one of the callbacks in the struct fails, grounding is stopped.
/// If a non-recoverable clingo API call fails, a callback must return false.
/// Otherwise ::clingo_error_unknown should be set and false returned.
///
/// @see clingo_control_register_observer()
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_ground_program_observer {
    /// Called once in the beginning.
    ///
    /// If the incremental flag is true, there can be multiple calls to @ref clingo_control_solve().
    ///
    /// **Parameters:**
    ///
    /// * `incremental` whether the program is incremental
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    pub init_program: ::std::option::Option<unsafe extern "C" fn(incremental:
                                                                     bool,
                                                                 data:
                                                                     *mut ::std::os::raw::c_void)
                                                -> bool>,
    /// Marks the beginning of a block of directives passed to the solver.
    ///
    /// @see @ref end_step
    ///
    /// **Parameters:**
    ///
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    pub begin_step: ::std::option::Option<unsafe extern "C" fn(data:
                                                                   *mut ::std::os::raw::c_void)
                                              -> bool>,
    /// Marks the end of a block of directives passed to the solver.
    ///
    /// This function is called before solving starts.
    ///
    /// @see @ref begin_step
    ///
    /// **Parameters:**
    ///
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    pub end_step: ::std::option::Option<unsafe extern "C" fn(data:
                                                                 *mut ::std::os::raw::c_void)
                                            -> bool>,
    /// Observe rules passed to the solver.
    ///
    /// **Parameters:**
    ///
    /// * `choice` determines if the head is a choice or a disjunction
    /// * `head` the head atoms
    /// * `head_size` the number of atoms in the head
    /// * `body` the body literals
    /// * `body_size` the number of literals in the body
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    pub rule: ::std::option::Option<unsafe extern "C" fn(choice: bool,
                                                         head:
                                                             *const clingo_atom_t,
                                                         head_size: usize,
                                                         body:
                                                             *const clingo_literal_t,
                                                         body_size: usize,
                                                         data:
                                                             *mut ::std::os::raw::c_void)
                                        -> bool>,
    /// Observe weight rules passed to the solver.
    ///
    /// **Parameters:**
    ///
    /// * `choice` determines if the head is a choice or a disjunction
    /// * `head` the head atoms
    /// * `head_size` the number of atoms in the head
    /// * `lower_bound` the lower bound of the weight rule
    /// * `body` the weighted body literals
    /// * `body_size` the number of weighted literals in the body
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    pub weight_rule: ::std::option::Option<unsafe extern "C" fn(choice: bool,
                                                                head:
                                                                    *const clingo_atom_t,
                                                                head_size:
                                                                    usize,
                                                                lower_bound:
                                                                    clingo_weight_t,
                                                                body:
                                                                    *const clingo_weighted_literal_t,
                                                                body_size:
                                                                    usize,
                                                                data:
                                                                    *mut ::std::os::raw::c_void)
                                               -> bool>,
    /// Observe minimize constraints (or weak constraints) passed to the solver.
    ///
    /// **Parameters:**
    ///
    /// * `priority` the priority of the constraint
    /// * `literals` the weighted literals whose sum to minimize
    /// * `size` the number of weighted literals
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    pub minimize: ::std::option::Option<unsafe extern "C" fn(priority:
                                                                 clingo_weight_t,
                                                             literals:
                                                                 *const clingo_weighted_literal_t,
                                                             size: usize,
                                                             data:
                                                                 *mut ::std::os::raw::c_void)
                                            -> bool>,
    /// Observe projection directives passed to the solver.
    ///
    /// **Parameters:**
    ///
    /// * `atoms` the atoms to project on
    /// * `size` the number of atoms
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    pub project: ::std::option::Option<unsafe extern "C" fn(atoms:
                                                                *const clingo_atom_t,
                                                            size: usize,
                                                            data:
                                                                *mut ::std::os::raw::c_void)
                                           -> bool>,
    /// Observe shown atoms passed to the solver.
    /// \note Facts do not have an associated aspif atom.
    /// The value of the atom is set to zero.
    ///
    /// **Parameters:**
    ///
    /// * `symbol` the symbolic representation of the atom
    /// * `atom` the aspif atom (0 for facts)
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    pub output_atom: ::std::option::Option<unsafe extern "C" fn(symbol:
                                                                    clingo_symbol_t,
                                                                atom:
                                                                    clingo_atom_t,
                                                                data:
                                                                    *mut ::std::os::raw::c_void)
                                               -> bool>,
    /// Observe shown terms passed to the solver.
    ///
    /// **Parameters:**
    ///
    /// * `symbol` the symbolic representation of the term
    /// * `condition` the literals of the condition
    /// * `size` the size of the condition
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    pub output_term: ::std::option::Option<unsafe extern "C" fn(symbol:
                                                                    clingo_symbol_t,
                                                                condition:
                                                                    *const clingo_literal_t,
                                                                size: usize,
                                                                data:
                                                                    *mut ::std::os::raw::c_void)
                                               -> bool>,
    /// Observe shown csp variables passed to the solver.
    ///
    /// **Parameters:**
    ///
    /// * `symbol` the symbolic representation of the variable
    /// * `value` the value of the variable
    /// * `condition` the literals of the condition
    /// * `size` the size of the condition
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    pub output_csp: ::std::option::Option<unsafe extern "C" fn(symbol:
                                                                   clingo_symbol_t,
                                                               value:
                                                                   ::std::os::raw::c_int,
                                                               condition:
                                                                   *const clingo_literal_t,
                                                               size: usize,
                                                               data:
                                                                   *mut ::std::os::raw::c_void)
                                              -> bool>,
    /// Observe external statements passed to the solver.
    ///
    /// **Parameters:**
    ///
    /// * `atom` the external atom
    /// * `type` the type of the external statement
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    pub external: ::std::option::Option<unsafe extern "C" fn(atom:
                                                                 clingo_atom_t,
                                                             type_:
                                                                 clingo_external_type_t,
                                                             data:
                                                                 *mut ::std::os::raw::c_void)
                                            -> bool>,
    /// Observe assumption directives passed to the solver.
    ///
    /// **Parameters:**
    ///
    /// * `literals` the literals to assume (positive literals are true and negative literals false for the next solve call)
    /// * `size` the number of atoms
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    pub assume: ::std::option::Option<unsafe extern "C" fn(literals:
                                                               *const clingo_literal_t,
                                                           size: usize,
                                                           data:
                                                               *mut ::std::os::raw::c_void)
                                          -> bool>,
    /// Observe heuristic directives passed to the solver.
    ///
    /// **Parameters:**
    ///
    /// * `atom` the target atom
    /// * `type` the type of the heuristic modification
    /// * `bias` the heuristic bias
    /// * `priority` the heuristic priority
    /// * `condition` the condition under which to apply the heuristic modification
    /// * `size` the number of atoms in the condition
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    pub heuristic: ::std::option::Option<unsafe extern "C" fn(atom:
                                                                  clingo_atom_t,
                                                              type_:
                                                                  clingo_heuristic_type_t,
                                                              bias:
                                                                  ::std::os::raw::c_int,
                                                              priority:
                                                                  ::std::os::raw::c_uint,
                                                              condition:
                                                                  *const clingo_literal_t,
                                                              size: usize,
                                                              data:
                                                                  *mut ::std::os::raw::c_void)
                                             -> bool>,
    /// Observe edge directives passed to the solver.
    ///
    /// **Parameters:**
    ///
    /// * `node_u` the start vertex of the edge
    /// * `node_v` the end vertex of the edge
    /// * `condition` the condition under which the edge is part of the graph
    /// * `size` the number of atoms in the condition
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    pub acyc_edge: ::std::option::Option<unsafe extern "C" fn(node_u:
                                                                  ::std::os::raw::c_int,
                                                              node_v:
                                                                  ::std::os::raw::c_int,
                                                              condition:
                                                                  *const clingo_literal_t,
                                                              size: usize,
                                                              data:
                                                                  *mut ::std::os::raw::c_void)
                                             -> bool>,
    /// Observe numeric theory terms.
    ///
    /// **Parameters:**
    ///
    /// * `term_id` the id of the term
    /// * `number` the value of the term
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    pub theory_term_number: ::std::option::Option<unsafe extern "C" fn(term_id:
                                                                           clingo_id_t,
                                                                       number:
                                                                           ::std::os::raw::c_int,
                                                                       data:
                                                                           *mut ::std::os::raw::c_void)
                                                      -> bool>,
    /// Observe string theory terms.
    ///
    /// **Parameters:**
    ///
    /// * `term_id` the id of the term
    /// * `name` the value of the term
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    pub theory_term_string: ::std::option::Option<unsafe extern "C" fn(term_id:
                                                                           clingo_id_t,
                                                                       name:
                                                                           *const ::std::os::raw::c_char,
                                                                       data:
                                                                           *mut ::std::os::raw::c_void)
                                                      -> bool>,
    /// Observe compound theory terms.
    ///
    /// The name_id_or_type gives the type of the compound term:
    /// - if it is -1, then it is a tuple
    /// - if it is -2, then it is a set
    /// - if it is -3, then it is a list
    /// - otherwise, it is a function and name_id_or_type refers to the id of the name (in form of a string term)
    ///
    /// **Parameters:**
    ///
    /// * `term_id` the id of the term
    /// * `name_id_or_type` the name or type of the term
    /// * `arguments` the arguments of the term
    /// * `size` the number of arguments
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    pub theory_term_compound: ::std::option::Option<unsafe extern "C" fn(term_id:
                                                                             clingo_id_t,
                                                                         name_id_or_type:
                                                                             ::std::os::raw::c_int,
                                                                         arguments:
                                                                             *const clingo_id_t,
                                                                         size:
                                                                             usize,
                                                                         data:
                                                                             *mut ::std::os::raw::c_void)
                                                        -> bool>,
    /// Observe theory elements.
    ///
    /// **Parameters:**
    ///
    ///
    /// * `element_id` - the id of the element
    /// * `terms` - the term tuple of the element
    /// * `terms_size` - the number of terms in the tuple
    /// * `condition` - the condition of the elemnt
    /// * `condition_size` - the number of literals in the condition
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    pub theory_element: ::std::option::Option<unsafe extern "C" fn(element_id:
                                                                       clingo_id_t,
                                                                   terms:
                                                                       *const clingo_id_t,
                                                                   terms_size:
                                                                       usize,
                                                                   condition:
                                                                       *const clingo_literal_t,
                                                                   condition_size:
                                                                       usize,
                                                                   data:
                                                                       *mut ::std::os::raw::c_void)
                                                  -> bool>,
    /// Observe theory atoms without guard.
    ///
    /// **Parameters:**
    ///
    /// * `atom_id_or_zero` the id of the atom or zero for directives
    /// * `term_id` the term associated with the atom
    /// * `elements` the elements of the atom
    /// * `size` the number of elements
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    pub theory_atom: ::std::option::Option<unsafe extern "C" fn(atom_id_or_zero:
                                                                    clingo_id_t,
                                                                term_id:
                                                                    clingo_id_t,
                                                                elements:
                                                                    *const clingo_id_t,
                                                                size: usize,
                                                                data:
                                                                    *mut ::std::os::raw::c_void)
                                               -> bool>,
    /// Observe theory atoms with guard.
    ///
    /// **Parameters:**
    ///
    /// * `atom_id_or_zero` the id of the atom or zero for directives
    /// * `term_id` the term associated with the atom
    /// * `elements` the elements of the atom
    /// * `size` the number of elements
    /// * `operator_id` the id of the operator (a string term)
    /// * `right_hand_side_id` the id of the term on the right hand side of the atom
    /// * `data` user data for the callback
    ///
    /// **Returns** whether the call was successful
    pub theory_atom_with_guard: ::std::option::Option<unsafe extern "C" fn(atom_id_or_zero:
                                                                               clingo_id_t,
                                                                           term_id:
                                                                               clingo_id_t,
                                                                           elements:
                                                                               *const clingo_id_t,
                                                                           size:
                                                                               usize,
                                                                           operator_id:
                                                                               clingo_id_t,
                                                                           right_hand_side_id:
                                                                               clingo_id_t,
                                                                           data:
                                                                               *mut ::std::os::raw::c_void)
                                                          -> bool>,
}
#[test]
fn bindgen_test_layout_clingo_ground_program_observer() {
    assert_eq!(::std::mem::size_of::<clingo_ground_program_observer>(),
               160usize,
               concat!("Size of: ", stringify!(clingo_ground_program_observer)));
    assert_eq!(::std::mem::align_of::<clingo_ground_program_observer>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_ground_program_observer)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ground_program_observer))
                       .init_program as *const _ as usize
               },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ground_program_observer),
                       "::",
                       stringify!(init_program)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ground_program_observer)).begin_step as *const _ as usize
               },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ground_program_observer),
                       "::",
                       stringify!(begin_step)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ground_program_observer)).end_step as *const _ as usize
               },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ground_program_observer),
                       "::",
                       stringify!(end_step)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ground_program_observer)).rule as *const _ as usize
               },
               24usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ground_program_observer),
                       "::",
                       stringify!(rule)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ground_program_observer)).weight_rule as *const _ as usize
               },
               32usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ground_program_observer),
                       "::",
                       stringify!(weight_rule)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ground_program_observer)).minimize as *const _ as usize
               },
               40usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ground_program_observer),
                       "::",
                       stringify!(minimize)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ground_program_observer)).project as *const _ as usize
               },
               48usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ground_program_observer),
                       "::",
                       stringify!(project)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ground_program_observer)).output_atom as *const _ as usize
               },
               56usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ground_program_observer),
                       "::",
                       stringify!(output_atom)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ground_program_observer)).output_term as *const _ as usize
               },
               64usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ground_program_observer),
                       "::",
                       stringify!(output_term)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ground_program_observer)).output_csp as *const _ as usize
               },
               72usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ground_program_observer),
                       "::",
                       stringify!(output_csp)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ground_program_observer)).external as *const _ as usize
               },
               80usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ground_program_observer),
                       "::",
                       stringify!(external)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ground_program_observer)).assume as *const _ as usize
               },
               88usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ground_program_observer),
                       "::",
                       stringify!(assume)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ground_program_observer)).heuristic as *const _ as usize
               },
               96usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ground_program_observer),
                       "::",
                       stringify!(heuristic)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ground_program_observer)).acyc_edge as *const _ as usize
               },
               104usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ground_program_observer),
                       "::",
                       stringify!(acyc_edge)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ground_program_observer))
                       .theory_term_number as *const _ as usize
               },
               112usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ground_program_observer),
                       "::",
                       stringify!(theory_term_number)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ground_program_observer))
                       .theory_term_string as *const _ as usize
               },
               120usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ground_program_observer),
                       "::",
                       stringify!(theory_term_string)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ground_program_observer))
                       .theory_term_compound as *const _ as usize
               },
               128usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ground_program_observer),
                       "::",
                       stringify!(theory_term_compound)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ground_program_observer))
                       .theory_element as *const _ as usize
               },
               136usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ground_program_observer),
                       "::",
                       stringify!(theory_element)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ground_program_observer)).theory_atom as *const _ as usize
               },
               144usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ground_program_observer),
                       "::",
                       stringify!(theory_atom)));
    assert_eq!(unsafe {
                   &(*(0 as *const clingo_ground_program_observer))
                       .theory_atom_with_guard as *const _ as usize
               },
               152usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_ground_program_observer),
                       "::",
                       stringify!(theory_atom_with_guard)));
}
impl Clone for clingo_ground_program_observer {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_ground_program_observer_t = clingo_ground_program_observer;
/// Struct used to specify the program parts that have to be grounded.
///
/// Programs may be structured into parts, which can be grounded independently with ::clingo_control_ground.
/// Program parts are mainly interesting for incremental grounding and multi-shot solving.
/// For single-shot solving, program parts are not needed.
///
///
/// **Note:** Parts of a logic program without an explicit <tt>\#program</tt>
/// specification are by default put into a program called `base` without
/// arguments.
///
/// @see clingo_control_ground()
#[repr(C)]
#[derive(Debug, Copy)]
pub struct clingo_part {
    /// < name of the program part
    pub name: *const ::std::os::raw::c_char,
    /// < array of parameters
    pub params: *const clingo_symbol_t,
    /// < number of parameters
    pub size: usize,
}
#[test]
fn bindgen_test_layout_clingo_part() {
    assert_eq!(::std::mem::size_of::<clingo_part>(),
               24usize,
               concat!("Size of: ", stringify!(clingo_part)));
    assert_eq!(::std::mem::align_of::<clingo_part>(),
               8usize,
               concat!("Alignment of ", stringify!(clingo_part)));
    assert_eq!(unsafe { &(*(0 as *const clingo_part)).name as *const _ as usize },
               0usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_part),
                       "::",
                       stringify!(name)));
    assert_eq!(unsafe { &(*(0 as *const clingo_part)).params as *const _ as usize },
               8usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_part),
                       "::",
                       stringify!(params)));
    assert_eq!(unsafe { &(*(0 as *const clingo_part)).size as *const _ as usize },
               16usize,
               concat!("Alignment of field: ",
                       stringify!(clingo_part),
                       "::",
                       stringify!(size)));
}
impl Clone for clingo_part {
    fn clone(&self) -> Self {
        *self
    }
}
pub type clingo_part_t = clingo_part;
/// Callback function to inject symbols.
///
/// **Parameters:**
///
/// * `symbols` - array of symbols
/// * `symbols_size` - size of the symbol array
/// * `data` - user data of the callback
///
/// **Returns** whether the call was successful; might set one of the following error codes:
/// - ::clingo_error_bad_alloc
/// @see ::clingo_ground_callback_t
pub type clingo_symbol_callback_t =
    ::std::option::Option<unsafe extern "C" fn(symbols: *const clingo_symbol_t,
                                                 symbols_size: usize,
                                                 data: *mut ::std::os::raw::c_void)
                                                 -> bool>;
/// Callback function to implement external functions.
///
/// If an external function of form <tt>\@name(parameters)</tt> occurs in a logic program,
/// then this function is called with its location, name, parameters, and a callback to inject symbols as arguments.
/// The callback can be called multiple times; all symbols passed are injected.
///
/// If a (non-recoverable) clingo API function fails in this callback, for example, the symbol callback, the callback must return false.
/// In case of errors not related to clingo, this function can set error ::clingo_error_unknown and return false to stop grounding with an error.
///
/// **Parameters:**
///
/// * `location` location from which the external function was called
/// * `name` name of the called external function
/// * `arguments` arguments of the called external function
/// * `arguments_size` number of arguments
/// * `data` user data of the callback
/// * `symbol_callback` function to inject symbols
/// * `symbol_callback_data` user data for the symbol callback
///            (must be passed untouched)
///
/// **Returns** whether the call was successful
/// @see clingo_control_ground()
///
/// The following example implements the external function <tt>\@f()</tt> returning 42.
/// ~~~~~~~~~~~~~~~{.c}
/// bool
/// ground_callback(clingo_location_t const *location,
///                 char const *name,
///                 clingo_symbol_t const *arguments,
///                 size_t arguments_size,
///                 void *data,
///                 clingo_symbol_callback_t symbol_callback,
///                 void *symbol_callback_data) {
///   if (strcmp(name, "f") == 0 && arguments_size == 0) {
///     clingo_symbol_t sym;
///     clingo_symbol_create_number(42, &sym);
///     return symbol_callback(&sym, 1, symbol_callback_data);
///   }
///   clingo_set_error(clingo_error_runtime, "function not found");
///   return false;
/// }
/// ~~~~~~~~~~~~~~~
pub type clingo_ground_callback_t =
    ::std::option::Option<unsafe extern "C" fn(location:
                                                   *const clingo_location_t,
                                               name:
                                                   *const ::std::os::raw::c_char,
                                               arguments:
                                                   *const clingo_symbol_t,
                                               arguments_size: usize,
                                               data:
                                                   *mut ::std::os::raw::c_void,
                                               symbol_callback:
                                                   clingo_symbol_callback_t,
                                               symbol_callback_data:
                                                   *mut ::std::os::raw::c_void)
                              -> bool>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_control([u8; 0]);
/// Control object holding grounding and solving state.
pub type clingo_control_t = clingo_control;
extern "C" {
    /// Create a new control object.
    ///
    /// A control object has to be freed using clingo_control_free().
    ///
    ///
    /// **Note:** Only gringo options (without <code>\-\-output</code>) and clasp`s options are supported as arguments,
    /// except basic options such as <code>\-\-help</code>.
    /// Furthermore, a control object is blocked while a search call is active;
    /// you must not call any member function during search.
    ///
    /// If the logger is NULL, messages are printed to stderr.
    ///
    /// **Parameters:**
    ///
    /// * `arguments` C string array of command line arguments
    /// * `arguments_size` size of the arguments array
    /// * `logger` callback functions for warnings and info messages
    /// * `logger_data` user data for the logger callback
    /// * `message_limit` maximum number of times the logger callback is called
    /// * `control` resulting control object
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    /// - ::clingo_error_runtime if argument parsing fails
    pub fn clingo_control_new(arguments: *const *const ::std::os::raw::c_char,
                              arguments_size: usize,
                              logger: clingo_logger_t,
                              logger_data: *mut ::std::os::raw::c_void,
                              message_limit: ::std::os::raw::c_uint,
                              control: *mut *mut clingo_control_t)
                              -> bool;
}
extern "C" {
    /// Free a control object created with clingo_control_new().
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    pub fn clingo_control_free(control: *mut clingo_control_t);
}
extern "C" {
    /// Extend the logic program with a program in a file.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `file` path to the file
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    /// - ::clingo_error_runtime if parsing or checking fails
    pub fn clingo_control_load(control: *mut clingo_control_t,
                               file: *const ::std::os::raw::c_char)
                               -> bool;
}
extern "C" {
    /// Extend the logic program with the given non-ground logic program in string form.
    ///
    /// This function puts the given program into a block of form: <tt>\#program name(parameters).</tt>
    ///
    /// After extending the logic program, the corresponding program parts are typically grounded with ::clingo_control_ground.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `name` name of the program block
    /// * `parameters` string array of parameters of the program block
    /// * `parameters_size` number of parameters
    /// * `program` string representation of the program
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    /// - ::clingo_error_runtime if parsing fails
    pub fn clingo_control_add(control: *mut clingo_control_t,
                              name: *const ::std::os::raw::c_char,
                              parameters: *const *const ::std::os::raw::c_char,
                              parameters_size: usize,
                              program: *const ::std::os::raw::c_char)
                              -> bool;
}
extern "C" {
    /// Ground the selected @link ::clingo_part parts @endlink of the current (non-ground) logic program.
    ///
    /// After grounding, logic programs can be solved with ::clingo_control_solve().
    ///
    ///
    /// **Note:** Parts of a logic program without an explicit <tt>\#program</tt>
    /// specification are by default put into a program called `base` without
    /// arguments.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `parts` array of parts to ground
    /// * `parts_size` size of the parts array
    /// * `ground_callback` callback to implement external functions
    /// * `ground_callback_data` user data for ground_callback
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    /// - error code of ground callback
    ///
    /// @see clingo_part
    pub fn clingo_control_ground(control: *mut clingo_control_t,
                                 parts: *const clingo_part_t,
                                 parts_size: usize,
                                 ground_callback: clingo_ground_callback_t,
                                 ground_callback_data: *mut ::std::os::raw::c_void)
                                 -> bool;
}
extern "C" {
    /// Solve the currently @link ::clingo_control_ground grounded @endlink logic program enumerating its models.
    ///
    /// See the @ref SolveHandle module for more information.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `mode` configures the search mode
    /// * `assumptions` array of assumptions to solve under
    /// * `assumptions_size` number of assumptions
    /// * `notify` the event handler to register
    /// * `data` the user data for the event handler
    /// * `handle` handle to the current search to enumerate models
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    /// - ::clingo_error_runtime if solving could not be started
    pub fn clingo_control_solve(control: *mut clingo_control_t,
                                mode: clingo_solve_mode_bitset_t,
                                assumptions: *const clingo_symbolic_literal_t,
                                assumptions_size: usize,
                                notify: clingo_solve_event_callback_t,
                                data: *mut ::std::os::raw::c_void,
                                handle: *mut *mut clingo_solve_handle_t)
                                -> bool;
}
extern "C" {
    /// Clean up the domains of clingo`s grounding component using the solving
    /// component`s top level assignment.
    ///
    /// This function removes atoms from domains that are false and marks atoms as
    /// facts that are true.  With multi-shot solving, this can result in smaller
    /// groundings because less rules have to be instantiated and more
    /// simplifications can be applied.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_control_cleanup(control: *mut clingo_control_t) -> bool;
}
extern "C" {
    /// Assign a truth value to an external atom.
    ///
    /// If the atom does not exist or is not external, this is a noop.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `atom` atom to assign
    /// * `value` the truth value
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_control_assign_external(control: *mut clingo_control_t,
                                          atom: clingo_symbol_t,
                                          value: clingo_truth_value_t)
                                          -> bool;
}
extern "C" {
    /// Release an external atom.
    ///
    /// After this call, an external atom is no longer external and subject to
    /// program simplifications.  If the atom does not exist or is not external,
    /// this is a noop.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `atom` atom to release
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_control_release_external(control: *mut clingo_control_t,
                                           atom: clingo_symbol_t)
                                           -> bool;
}
extern "C" {
    /// Register a custom propagator with the control object.
    ///
    /// If the sequential flag is set to true, the propagator is called
    /// sequentially when solving with multiple threads.
    ///
    /// See the @ref Propagator module for more information.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `propagator` the propagator
    /// * `data` user data passed to the propagator functions
    /// * `sequential` whether the propagator should be called sequentially
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_control_register_propagator(control: *mut clingo_control_t,
                                              propagator: *const clingo_propagator_t,
                                              data: *mut ::std::os::raw::c_void,
                                              sequential: bool)
                                              -> bool;
}
extern "C" {
    /// Get a statistics object to inspect solver statistics.
    ///
    /// Statistics are updated after a solve call.
    ///
    /// See the @ref Statistics module for more information.
    ///
    /// @attention
    /// The level of detail of the statistics depends on the stats option
    /// (which can be set using @ref Configuration module or passed as an option when @link clingo_control_new creating the control object@endlink).
    /// The default level zero only provides basic statistics,
    /// level one provides extended and accumulated statistics,
    /// and level two provides per-thread statistics.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `statistics` the statistics object
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_control_statistics(control: *mut clingo_control_t,
                                     statistics: *mut *mut clingo_statistics_t)
                                     -> bool;
}
extern "C" {
    /// Interrupt the active solve call (or the following solve call right at the beginning).
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    pub fn clingo_control_interrupt(control: *mut clingo_control_t);
}
extern "C" {
    /// Get low-level access to clasp.
    ///
    /// @attention
    /// This function is intended for experimental use only and not part of the stable API.
    ///
    /// This function may return a <code>nullptr</code>.
    /// Otherwise, the returned pointer can be casted to a ClaspFacade pointer.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `clasp` pointer to the ClaspFacade object (may be <code>nullptr</code>)
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_control_clasp_facade(control: *mut clingo_control_t,
                                       clasp: *mut *mut ::std::os::raw::c_void)
                                       -> bool;
}
extern "C" {
    /// Get a configuration object to change the solver configuration.
    ///
    /// See the @ref Configuration module for more information.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `configuration` the configuration object
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_control_configuration(control: *mut clingo_control_t,
                                        configuration: *mut *mut clingo_configuration_t)
                                        -> bool;
}
extern "C" {
    /// Configure how learnt constraints are handled during enumeration.
    ///
    /// If the enumeration assumption is enabled, then all information learnt from
    /// the solver`s various enumeration modes is removed after a solve call. This
    /// includes enumeration of cautious or brave consequences, enumeration of
    /// answer sets with or without projection, or finding optimal models, as well
    /// as clauses added with clingo_solve_control_add_clause().
    ///
    /// @attention For practical purposes, this option is only interesting for single-shot solving
    /// or before the last solve call to squeeze out a tiny bit of performance.
    /// Initially, the enumeration assumption is enabled.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `enable` whether to enable the assumption
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_control_use_enumeration_assumption(control: *mut clingo_control_t,
                                                     enable: bool)
                                                     -> bool;
}
extern "C" {
    /// Return the symbol for a constant definition of form: <tt>\#const name = symbol</tt>.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `name` the name of the constant
    /// * `symbol` the resulting symbol
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_control_get_const(control: *mut clingo_control_t,
                                    name: *const ::std::os::raw::c_char,
                                    symbol: *mut clingo_symbol_t)
                                    -> bool;
}
extern "C" {
    /// Check if there is a constant definition for the given constant.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `name` the name of the constant
    /// * `exists` whether a matching constant definition exists
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_runtime if constant definition does not exist
    ///
    /// @see clingo_control_get_const()
    pub fn clingo_control_has_const(control: *mut clingo_control_t,
                                    name: *const ::std::os::raw::c_char,
                                    exists: *mut bool)
                                    -> bool;
}
extern "C" {
    /// Get an object to inspect symbolic atoms (the relevant Herbrand base) used
    /// for grounding.
    ///
    /// See the @ref SymbolicAtoms module for more information.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `atoms` the symbolic atoms object
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_control_symbolic_atoms(control: *mut clingo_control_t,
                                         atoms: *mut *mut clingo_symbolic_atoms_t)
                                         -> bool;
}
extern "C" {
    /// Get an object to inspect theory atoms that occur in the grounding.
    ///
    /// See the @ref TheoryAtoms module for more information.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `atoms` the theory atoms object
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_control_theory_atoms(control: *mut clingo_control_t,
                                       atoms: *mut *mut clingo_theory_atoms_t)
                                       -> bool;
}
extern "C" {
    /// Register a program observer with the control object.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `observer` the observer to register
    /// * `replace` just pass the grounding to the observer but not the solver
    /// * `data` user data passed to the observer functions
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_control_register_observer(control: *mut clingo_control_t,
                                            observer: *const clingo_ground_program_observer_t,
                                            replace: bool,
                                            data: *mut ::std::os::raw::c_void)
                                            -> bool;
}
extern "C" {
    /// Get an object to add ground directives to the program.
    ///
    /// See the @ref ProgramBuilder module for more information.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `backend` the backend object
    ///
    /// **Returns** whether the call was successful; might set one of the following error codes:
    /// - ::clingo_error_bad_alloc
    pub fn clingo_control_backend(control: *mut clingo_control_t,
                                  backend: *mut *mut clingo_backend_t)
                                  -> bool;
}
extern "C" {
    /// Get an object to add non-ground directives to the program.
    ///
    /// See the @ref ProgramBuilder module for more information.
    ///
    /// **Parameters:**
    ///
    /// * `control` the target
    /// * `builder` the program builder object
    ///
    /// **Returns** whether the call was successful
    pub fn clingo_control_program_builder(control: *mut clingo_control_t,
                                          builder: *mut *mut clingo_program_builder_t)
                                          -> bool;
}
